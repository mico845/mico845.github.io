<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>ADC和DAC——跟我一起写STM32(第九期) | 瑞奇的博客</title><meta name="author" content="瑞奇"><meta name="copyright" content="瑞奇"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="文章目录  11 ADC  11.1 走进ADC 11.2 ADC配置  11.2.1 排队问题 11.2.2 触发源 11.2.3 转换时间 11.2.4 数据对齐 11.2.5 ADC模式   11.3 ADC轮询采集 11.4 用上DMA传输ADC 11.5 多通道采集 11.6 过采集求均值提高分辨率 11.7 双ADC同步转换   12 DAC  12.1 走进DAC 12.2 DAC">
<meta property="og:type" content="article">
<meta property="og:title" content="ADC和DAC——跟我一起写STM32(第九期)">
<meta property="og:url" content="https://rich-blog.cn/2023/01/17/STM32/ADC%E5%92%8CDAC%E2%80%94%E2%80%94%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99STM32(%E7%AC%AC%E4%B9%9D%E6%9C%9F)/index.html">
<meta property="og:site_name" content="瑞奇的博客">
<meta property="og:description" content="文章目录  11 ADC  11.1 走进ADC 11.2 ADC配置  11.2.1 排队问题 11.2.2 触发源 11.2.3 转换时间 11.2.4 数据对齐 11.2.5 ADC模式   11.3 ADC轮询采集 11.4 用上DMA传输ADC 11.5 多通道采集 11.6 过采集求均值提高分辨率 11.7 双ADC同步转换   12 DAC  12.1 走进DAC 12.2 DAC">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://rich-blog.cn/img/cover/1.jpg">
<meta property="article:published_time" content="2023-01-17T11:20:41.000Z">
<meta property="article:modified_time" content="2023-02-13T09:15:02.623Z">
<meta property="article:author" content="瑞奇">
<meta property="article:tag" content="stm32">
<meta property="article:tag" content="单片机">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="c语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rich-blog.cn/img/cover/1.jpg"><link rel="shortcut icon" href="/img/panda.png"><link rel="canonical" href="https://rich-blog.cn/2023/01/17/STM32/ADC%E5%92%8CDAC%E2%80%94%E2%80%94%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99STM32(%E7%AC%AC%E4%B9%9D%E6%9C%9F)/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ADC和DAC——跟我一起写STM32(第九期)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-13 17:15:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="瑞奇的博客" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/pearl.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover/1.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="瑞奇的博客"><span class="site-name">瑞奇的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ADC和DAC——跟我一起写STM32(第九期)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-17T11:20:41.000Z" title="发表于 2023-01-17 19:20:41">2023-01-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-13T09:15:02.623Z" title="更新于 2023-02-13 17:15:02">2023-02-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99STM32/">跟我一起写STM32</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ADC和DAC——跟我一起写STM32(第九期)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><span id="more"></span>
<h3 id="文章目录">文章目录</h3>
<ul>
<li><a href="#11-adc">11 ADC</a>
<ul>
<li><a href="#111-%E8%B5%B0%E8%BF%9Badc">11.1 走进ADC</a></li>
<li><a href="#112-adc%E9%85%8D%E7%BD%AE">11.2 ADC配置</a>
<ul>
<li><a href="#1121-%E6%8E%92%E9%98%9F%E9%97%AE%E9%A2%98">11.2.1 排队问题</a></li>
<li><a href="#1122-%E8%A7%A6%E5%8F%91%E6%BA%90">11.2.2 触发源</a></li>
<li><a href="#1123-%E8%BD%AC%E6%8D%A2%E6%97%B6%E9%97%B4">11.2.3 转换时间</a></li>
<li><a href="#1124-%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90">11.2.4 数据对齐</a></li>
<li><a href="#1125-adc%E6%A8%A1%E5%BC%8F">11.2.5 ADC模式</a></li>
</ul>
</li>
<li><a href="#113-adc%E8%BD%AE%E8%AF%A2%E9%87%87%E9%9B%86">11.3 ADC轮询采集</a></li>
<li><a href="#114-%E7%94%A8%E4%B8%8Adma%E4%BC%A0%E8%BE%93adc">11.4 用上DMA传输ADC</a></li>
<li><a href="#115-%E5%A4%9A%E9%80%9A%E9%81%93%E9%87%87%E9%9B%86">11.5 多通道采集</a></li>
<li><a href="#116-%E8%BF%87%E9%87%87%E9%9B%86%E6%B1%82%E5%9D%87%E5%80%BC%E6%8F%90%E9%AB%98%E5%88%86%E8%BE%A8%E7%8E%87">11.6 过采集求均值提高分辨率</a></li>
<li><a href="#117-%E5%8F%8Cadc%E5%90%8C%E6%AD%A5%E8%BD%AC%E6%8D%A2">11.7 双ADC同步转换</a></li>
</ul>
</li>
<li><a href="#12-dac">12 DAC</a>
<ul>
<li><a href="#121-%E8%B5%B0%E8%BF%9Bdac">12.1 走进DAC</a></li>
<li><a href="#122-dac%E9%85%8D%E7%BD%AE">12.2 DAC配置</a></li>
<li><a href="#123-dac%E8%BE%93%E5%87%BA%E7%94%B5%E5%8E%8B">12.3 DAC输出电压</a></li>
<li><a href="#123-dac%E7%9B%B4%E6%8E%A5%E8%BE%93%E5%87%BA%E4%B8%89%E8%A7%92%E6%B3%A2">12.3 DAC直接输出三角波</a></li>
<li><a href="#124-%E7%94%A8dma%E8%AE%A9dac%E8%BE%93%E5%87%BA%E6%AD%A3%E5%BC%A6%E6%B3%A2">12.4 用DMA让DAC输出正弦波</a></li>
</ul>
</li>
</ul>
<h1 id="11-adc">11 ADC</h1>
<p>这里的ADC不是射手（雾），这里的ADC是Analog-to-Digital Converter，翻译一下就是模拟到数字的意思。<br>
总所周知，模拟信号是指用连续变化的物理量所表达的信息，如温度、湿度、压力、长度、电流、电压等等，我们通常又把模拟信号称为连续信号，它在一定的时间范围内可以有无限多个不同的取值。而数字信号是指在取值上是离散的、不连续的信号，如在计算机中，数字信号的大小常用有限位的二进制数表示。<br>
具体可以参考：<br>
<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7/706796">模拟信号</a><br>
<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7/915663">数字信号</a></p>
<p>而ADC和DAC这样的物件，就能构起模拟与数字之间的大桥。</p>
<h2 id="11-1-走进adc">11.1 走进ADC</h2>
<p>推荐补课视频：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/45917d8af2874d73aae3bb52efefc1f3.png" alt=""></p>
<p>传感器采集模拟量，通过ADC得到数字量，并交给单片机处理。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/36d60d6889dc4d9195aae412c33e7871.png" alt=""></p>
<p>ADC将会<strong>采样、保持、量化、编码</strong>，把模拟量电压转化为数字量</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/3e35d091652340ff8485a5a4c7559c73.png#pic_center" alt=""></p>
<p>就比如一个3位ADC，采样的范围就是0到2的3次方，即0~8<br>
若它的参考电压为3.3v，GND为0，<br>
就等于0-3.3v映射为了0-8的数字。<br>
比如数字1就是 （1/8）*3.3V的模拟值</p>
<p>拿小蜜蜂老师的经典例题为例：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/85881300175349e5b9ad30d9e6cf89ab.png" alt=""></p>
<p>详情参考：<br>
b站：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1m7411H7oT?p=8">【小蜜蜂笔记】基于STM32CubeMX的嵌入式开发基础教程——ADC模数转换器基本工作原理</a><br>
好文推荐：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/462841831">一篇易懂的模数转换器（ADC）学习笔记1</a></p>
<p>最基本的ADC类型：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/ab0e37ac42a448a8baf8d3be59605586.png" alt=""><br>
并联比较型：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/b643988a2853418ea9b071ec66df947f.png" alt=""><br>
这里只是一个3位ADC，用了2的3次方个电阻和比较器。<br>
每增加ADC分辨率（分辨率表示ADC能辨别的最小模拟量，用二进制位数表示，比如：8、10、12、16位），都会增加2的次方倍的比较器和电阻。</p>
<p>逐次逼近型：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/819924512a484dd8a792c24011ea72f7.png" alt=""><br>
每次比较一位，三次比较下来才能得到3位ADC的数字值，是拿速度换分辨率的方法。</p>
<p>STM32f103系列有3个ADC（都是逐次逼近型）精度为12位，每个ADC最多有16个外部通道。其中ADC1和ADC2都有16个外部通道，ADC3一般有8个外部通道，各通道的A/D转换可以单次、连续、扫描或间断执行，ADC转换的结果可以左对齐或右对齐储存在16位数据寄存器中。ADC的输入时钟不得超过14MHz，其时钟频率由PCLK2分频产生。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/51cc796bd0a0483d9ebd25a8f95d639f.png" alt=""></p>
<h2 id="11-2-adc配置">11.2 ADC配置</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/08a5598fc70e45fb82d34c11d9e59c91.png#pic_center" alt=""></p>
<h3 id="11-2-1-排队问题">11.2.1 排队问题</h3>
<p>A/D转换被组织为两组：<strong>规则组</strong>（常规转换组）和<strong>注入组</strong>（注入转换组）<br>
规则组最多可以有16个转换，注入组最多有4个转换</p>
<p>顾名思义，规则组按照规矩依次办事，注入组会插队，大体如图：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/e26878406d4649039854c92298d729e2.png" alt=""></p>
<h3 id="11-2-2-触发源">11.2.2 触发源</h3>
<p>软件触发、定时器触发…<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/7aff7b1e1de7482cbeccb1dc0935e702.png#pic_center" alt=""></p>
<p>当然也可以EXTI触发ADC：<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45691873/article/details/120810254">STM32复习笔记(十二) —— ADC(EXTI事件触发)采集电压</a><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/988141c440134b58af3d811bab78b052.png#pic_center" alt=""></p>
<h3 id="11-2-3-转换时间">11.2.3 转换时间</h3>
<p><strong>ADC时钟</strong>：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/e1c2cce2e48345e1ba95a7e73c590303.png" alt=""><br>
笔者的配置为：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/8e42187ed4264d7998f140ce901955c8.png" alt=""></p>
<p>配置好了时钟，那我们就能计算<strong>ADC的转化时间</strong>了</p>
<blockquote>
<p>ADC转换时间： T = 采样时间 + 12.5个周期</p>
</blockquote>
<p>采样时间我们可以自行配置：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/388f9519fd4143ad89837c42cce2c26c.png#pic_center" alt=""><br>
时间越久精度越高</p>
<h3 id="11-2-4-数据对齐">11.2.4 数据对齐</h3>
<p>采集数据是存放在寄存器里<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/2aa29f0a81e34abcbe4a8ef445fa6348.png" alt=""><br>
但是寄存器都是32位或者16位，而笔者ADC仅仅12位，这样存放数据时就有讲究了。<br>
可以选择存放在高12位或者低12位，即左对齐或者右对齐</p>
<h3 id="11-2-5-adc模式">11.2.5 ADC模式</h3>
<p>这个就比较重要了，大体很多人ADC出问题，都是模式没调好。</p>
<p><strong>转化模式</strong></p>
<table>
<thead>
<tr>
<th>CONT位</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>转化模式</td>
<td>单次转化模式</td>
<td>连续转化模式</td>
</tr>
</tbody>
</table>
<p><strong>单次转换模式</strong><br>
只触发一次转换</p>
<p><strong>连续转换模式</strong><br>
自动触发下一次转换<br>
<strong>注意：只有规则组才能触发该模式</strong></p>
<p>可以参考：<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41174547/article/details/124843969">HAL ADC连续转换模式 Continuous Conversion Mode</a></p>
<p><strong>扫描模式</strong></p>
<table>
<thead>
<tr>
<th>SCAN位</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>扫描模式</td>
<td>关</td>
<td>开</td>
</tr>
</tbody>
</table>
<p><strong>关闭扫描模式</strong></p>
<p>ADC只转换选中的第一个通道进行转换</p>
<p><strong>使用扫描模式</strong><br>
ADC会扫描所有选中的所有通道</p>
<p><strong>间断模式——不连续采样模式</strong><br>
这个笔者用的比较少，这里不做介绍，大家可以自行了解。</p>
<p><strong>不同模式组合的作用</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/94897d49dfeb45cca4858d34b6af1ba0.png" alt=""><br>
具体例子：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/68e68840efca46f5a0a41f7d11d9c1b6.png" alt=""></p>
<p>总而言之，若开启连续转化，就不用自己再手动再次使能，反之，若没开启，再次想使用时就一定自己手动打开。<br>
连续转化的时间就是我们刚刚计算的转化时间。<br>
一般，用定时器触发时，就会关闭连续转化。</p>
<h2 id="11-3-adc轮询采集">11.3 ADC轮询采集</h2>
<p>配置ADC<br>
在前面，我们已经说过了他们这些选项的具体含义，现在我们直接选择：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/e58342be395b4040bbde0e6905ac6f3a.png#pic_center" alt=""><br>
扫描模式无法关闭，但我们只配置一个通道（若只配置一个通道，也算是关闭了扫描模式了吧）<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/2968307c6df24ad2ae53cada287ddbcb.png#pic_center" alt=""></p>
<p>生成工程</p>
<p>因为我们没有使能连续模式，所以我们每次使用ADC前要开启ADC<br>
我们编写开启ADC，并获取ADC值的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">u32 _adc_get_resule_pollfor(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    HAL_ADC_Start(&amp;hadc1);</span><br><span class="line">    HAL_ADC_PollForConversion(&amp;hadc1, <span class="number">10</span>);<span class="comment">//等待规则通道转换完成</span></span><br><span class="line">    <span class="keyword">return</span> (u16)HAL_ADC_GetValue(&amp;hadc1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里轮询时间10ms，远远大于我们的采样时间了。</p>
<p>为了让我们的值更加精确，我们通常要对采样得到的值进行求平均：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">u32 <span class="title function_">adc_get_resule_pollfor</span><span class="params">(u8 times)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 temp_val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; times; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp_val += _adc_get_resule_pollfor();</span><br><span class="line">        delay_ms(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (temp_val / times);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用LCD屏幕把它显示出来就是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">   bsp_init();</span><br><span class="line">   painter.size = LCD_FONTSIZE_1206;</span><br><span class="line">   painter.color = BLACK;</span><br><span class="line">   painter.back_color=LGRAY;</span><br><span class="line">   lcd_clear();</span><br><span class="line">   lcd_clear();</span><br><span class="line">lcd_show_string(<span class="number">5</span>, <span class="number">50</span>,(u8*)<span class="string">&quot;ADC1_CH1_VAL:&quot;</span>);</span><br><span class="line">   lcd_show_string(<span class="number">5</span>, <span class="number">62</span>,(u8*)<span class="string">&quot;ADC1_CH1_VOL:0.000V&quot;</span>);</span><br><span class="line"> <span class="comment">/* USER CODE END 2 */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Infinite loop */</span></span><br><span class="line"> <span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">   u32 adcx;</span><br><span class="line">   <span class="type">float</span> temp;</span><br><span class="line">   painter.color=BLUE;</span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       adcx = adc_get_resule_pollfor(<span class="number">10</span>);</span><br><span class="line">       lcd_show_num(<span class="number">83</span>, <span class="number">50</span>, adcx, <span class="number">5</span>);</span><br><span class="line">       temp=(<span class="type">float</span> )adcx * (<span class="number">3.3</span>/<span class="number">4096</span>);</span><br><span class="line">       adcx = temp;</span><br><span class="line">       lcd_show_num(<span class="number">83</span>, <span class="number">62</span> , adcx, <span class="number">1</span>);</span><br><span class="line">       temp -= adcx;</span><br><span class="line">       temp *= <span class="number">1000</span>;</span><br><span class="line">       lcd_show_num(<span class="number">95</span>, <span class="number">62</span>, temp, <span class="number">3</span>);</span><br><span class="line">       delay_ms(<span class="number">100</span>);</span><br><span class="line">   <span class="comment">/* USER CODE END WHILE */</span></span><br></pre></td></tr></table></figure>
<h2 id="11-4-用上dma传输adc">11.4 用上DMA传输ADC</h2>
<p>但有朋友就要说了，你这轮询采集ADC不就浪费时间了嘛。<br>
于是，我们用上之前说过的数据的搬运工——DMA。<br>
配置DMA<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/6fb428ef93c54dbb9622b78cb05c3052.png#pic_center" alt=""><br>
stm32是32位处理器，所以一个word就对应32位，一个half word就对应16位。根据需要传输数据的大小选择对应Data Width即可。<br>
例如笔者使用ADC进行数据采集，ADC的精度是12位的，所以Data Width选择half word就够用了。</p>
<p>Mode选择Normal，所以每次传输完数据得自己手动再次开启DMA传输。</p>
<p>这里我们使能<strong>连续转化模式</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/9da27d1483904e92997d1b0a225fa732.png#pic_center" alt=""><br>
因为如果不使能连续模式，ADC只转化一次，那我们若打算使用数组存放DMA缓存的话，DMA就一直得不到完成中断<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/02bf5846714948babf05e13cab421984.png" alt=""></p>
<p>于是，我们生成工程</p>
<p>编写DMA中断服务函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">u8 adc_dma_sta;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA1_Channel1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (DMA1-&gt;ISR &amp; (<span class="number">1</span> &lt;&lt; <span class="number">1</span>))<span class="comment">//通道1传输完成</span></span><br><span class="line">    &#123;</span><br><span class="line">        adc_dma_sta = <span class="number">1</span>;<span class="comment">//标识传输完成</span></span><br><span class="line">        DMA1-&gt;IFCR |= (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);<span class="comment">//清除标志位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/b59b38d8a1d44f9f8d114af3fb613df7.png#pic_center" alt=""></p>
<p>给IFCR寄存器对应位写1可清除标志位</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/f30a69c39fc54f90a5cd1f1f9cf79e1f.png#pic_center" alt=""><br>
当然，我们自己写了DMA中断服务函数之后就要把HAL库生成的注释掉：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/24f24b8b722e4075b9ccc1711e890f41.png#pic_center" alt=""></p>
<p>这个函数负责设置DMA传输数量，当DMA传输数量为0时，视为停止</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc_dma_enable</span><span class="params">(u16 cndtr)</span></span><br><span class="line">&#123;</span><br><span class="line">    ADC1-&gt;CR2 &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">0</span>);                 <span class="comment">//__HAL_ADC_DISABLE(&amp;hadc1);</span></span><br><span class="line">    DMA1_Channel1-&gt;CCR &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">0</span>);        <span class="comment">//__HAL_DMA_DISABLE(&amp;hdma_adc1);</span></span><br><span class="line">    <span class="keyword">while</span> (DMA1_Channel1-&gt;CCR &amp; (<span class="number">1</span> &lt;&lt; <span class="number">0</span>));  </span><br><span class="line">    <span class="comment">// while (__HAL_DMA_GET_FLAG(&amp;hdma_adc1, __HAL_DMA_GET_TC_FLAG_INDEX(&amp;hdma_adc1)));</span></span><br><span class="line">    DMA1_Channel1-&gt;CNDTR = cndtr;	<span class="comment">//设置DMA传输数量</span></span><br><span class="line">    DMA1_Channel1-&gt;CCR |= (<span class="number">1</span> &lt;&lt; <span class="number">0</span>);         <span class="comment">//__HAL_DMA_ENABLE(&amp;hdma_adc1);</span></span><br><span class="line">    ADC1-&gt;CR2 |= (<span class="number">1</span> &lt;&lt; <span class="number">0</span>);                  <span class="comment">//__HAL_ADC_ENABLE(&amp;hadc1);</span></span><br><span class="line">    ADC1-&gt;CR2 |= (<span class="number">1</span> &lt;&lt; <span class="number">22</span>);                 <span class="comment">//HAL_ADC_Start(&amp;hadc1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ADC的CR2寄存器控制开关、和使能规则组通道转化<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/c1d29735a2ad47bf9701958908c3bcfc.png#pic_center" alt=""><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/97ba4b43fbac4453b60a2b2580aeb9cf.png#pic_center" alt=""><br>
DMA的CCR控制开关<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/83a23c3589774e2eb39a320c0209367c.png#pic_center" alt=""><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/ed110d3cfdfe40938a17db0d37b335c6.png#pic_center" alt=""><br>
CNDTR控制DMA数据量<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/4cb19fe3bbfd475cb38b03e23eed7d39.png#pic_center" alt=""></p>
<p>接着我们编写一个给DMA目标地址赋值的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">u32 mar;</span><br><span class="line">u32 <span class="title function_">adc_dam_address</span><span class="params">(u32 _mar)</span></span><br><span class="line">&#123;</span><br><span class="line">    mar = _mar;</span><br><span class="line">    <span class="keyword">return</span> mar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并使能DMA</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HAL_DMA_Start_IT(&amp;hdma_adc1, (u32)&amp;ADC1-&gt;DR, mar,<span class="number">0</span>);</span><br><span class="line">HAL_ADC_Start_DMA(&amp;hadc1, &amp;mar, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>当然使能前，也可以校准一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_ADCEx_Calibration_Start(&amp;hadc1);</span><br></pre></td></tr></table></figure>
<p>于是，我们的代码就有了</p>
<p>生成目标地址数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AVERAGE_TIMES 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_BUF_SIZE  AVERAGE_TIMES</span></span><br><span class="line">u16 adc_buf[ADC_BUF_SIZE];</span><br></pre></td></tr></table></figure>
<p>接着传入目标地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc_dam_address((u32)&amp;adc_buf);</span><br></pre></td></tr></table></figure>
<p>使能它</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_ADCEx_Calibration_Start(&amp;hadc1);</span><br><span class="line">HAL_DMA_Start_IT(&amp;hdma_adc1, (u32)&amp;ADC1-&gt;DR, mar,<span class="number">0</span>);</span><br><span class="line">HAL_ADC_Start_DMA(&amp;hadc1, &amp;mar, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>在判断DMA传输完成后显示出来</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">    u32 adcx;</span><br><span class="line">    <span class="type">float</span> temp;</span><br><span class="line">    painter.color=BLUE;</span><br><span class="line">    adc_dma_enable(ADC_BUF_SIZE);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (adc_dma_sta)</span><br><span class="line">        &#123;</span><br><span class="line">            adcx = adc_get_resule_pollfor(<span class="number">10</span>);</span><br><span class="line">            lcd_show_num(<span class="number">83</span>, <span class="number">50</span>, adcx, <span class="number">5</span>);</span><br><span class="line">            temp=(<span class="type">float</span> )adcx * (<span class="number">3.3</span>/<span class="number">4096</span>);</span><br><span class="line">            adcx = temp;</span><br><span class="line">            lcd_show_num(<span class="number">83</span>, <span class="number">62</span> , adcx, <span class="number">1</span>);</span><br><span class="line">            temp -= adcx;</span><br><span class="line">            temp *= <span class="number">1000</span>;</span><br><span class="line">            lcd_show_num(<span class="number">95</span>, <span class="number">62</span>, temp, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">            adc_dma_sta = <span class="number">0</span>;</span><br><span class="line">            adc_dma_enable(ADC_BUF_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">        delay_ms(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br></pre></td></tr></table></figure>
<h2 id="11-5-多通道采集">11.5 多通道采集</h2>
<p>前面说过有扫描模式，那我们整个8通道ADC扫描来玩玩。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/c4cac122ac2c40219fdffd25e39dd16b.png#pic_center" alt=""><br>
这里设置为<strong>连续模式</strong><br>
配置每个通道<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/cc671fdaf7a840ef8a59ee3d53cfd8db.png#pic_center" alt=""><br>
规划每个通道的内存大小<br>
这里笔者的配置为8个通道，每个通道读50次（用于取平均值），一次一共400的DMA传输大小<br>
其中数据排列的顺序是123456781234567812345678…一个有400个数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_N_CHANNEL (8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_BUF_SIZE (50 * ADC_N_CHANNEL)</span></span><br><span class="line">u16 adc_buf[ADC_BUF_SIZE];</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">    bsp_init();</span><br><span class="line">    painter.size = LCD_FONTSIZE_1206;</span><br><span class="line">    painter.color = BLACK;</span><br><span class="line">    painter.back_color=LGRAY;</span><br><span class="line">    lcd_clear();</span><br><span class="line">    lcd_clear();</span><br><span class="line">    lcd_show_string(<span class="number">5</span>, <span class="number">50</span>,(u8*)<span class="string">&quot;ADC1_CH1_VAL:&quot;</span>);</span><br><span class="line">    lcd_show_string(<span class="number">5</span>, <span class="number">62</span>,(u8*)<span class="string">&quot;ADC1_CH1_VOL:0.000V&quot;</span>);</span><br><span class="line">    lcd_show_string(<span class="number">5</span>, <span class="number">80</span>,(u8*)<span class="string">&quot;ADC1_CH2_VAL:&quot;</span>);</span><br><span class="line">    lcd_show_string(<span class="number">5</span>, <span class="number">92</span>,(u8*)<span class="string">&quot;ADC1_CH2_VOL:0.000V&quot;</span>);</span><br><span class="line">    lcd_show_string(<span class="number">5</span>, <span class="number">110</span>,(u8*)<span class="string">&quot;ADC1_CH3_VAL:&quot;</span>);</span><br><span class="line">    lcd_show_string(<span class="number">5</span>, <span class="number">122</span>,(u8*)<span class="string">&quot;ADC1_CH3_VOL:0.000V&quot;</span>);</span><br><span class="line">    lcd_show_string(<span class="number">5</span>, <span class="number">140</span>,(u8*)<span class="string">&quot;ADC1_CH4_VAL:&quot;</span>);</span><br><span class="line">    lcd_show_string(<span class="number">5</span>, <span class="number">152</span>,(u8*)<span class="string">&quot;ADC1_CH4_VOL:0.000V&quot;</span>);</span><br><span class="line">    lcd_show_string(<span class="number">5</span>, <span class="number">170</span>,(u8*)<span class="string">&quot;ADC1_CH5_VAL:&quot;</span>);</span><br><span class="line">    lcd_show_string(<span class="number">5</span>, <span class="number">182</span>,(u8*)<span class="string">&quot;ADC1_CH5_VOL:0.000V&quot;</span>);</span><br><span class="line">    lcd_show_string(<span class="number">5</span>, <span class="number">200</span>,(u8*)<span class="string">&quot;ADC1_CH6_VAL:&quot;</span>);</span><br><span class="line">    lcd_show_string(<span class="number">5</span>, <span class="number">212</span>,(u8*)<span class="string">&quot;ADC1_CH6_VOL:0.000V&quot;</span>);</span><br><span class="line">    lcd_show_string(<span class="number">5</span>, <span class="number">230</span>,(u8*)<span class="string">&quot;ADC1_CH7_VAL:&quot;</span>);</span><br><span class="line">    lcd_show_string(<span class="number">5</span>, <span class="number">242</span>,(u8*)<span class="string">&quot;ADC1_CH7_VOL:0.000V&quot;</span>);</span><br><span class="line">    lcd_show_string(<span class="number">5</span>, <span class="number">260</span>,(u8*)<span class="string">&quot;ADC1_CH8_VAL:&quot;</span>);</span><br><span class="line">    lcd_show_string(<span class="number">5</span>, <span class="number">272</span>,(u8*)<span class="string">&quot;ADC1_CH8_VOL:0.000V&quot;</span>);</span><br><span class="line">  <span class="comment">/* USER CODE END 2 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">    u16 adcx;</span><br><span class="line">    <span class="type">float</span> temp;</span><br><span class="line">    u32 sum;</span><br><span class="line">    painter.color=BLUE;</span><br><span class="line">    u32 colour[]=&#123;BLUE,GREEN,RED,MAGENTA,LBBLUE,BROWN,YELLOW,GRAY&#125;;</span><br><span class="line">    adc_dma_enable(ADC_BUF_SIZE);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(adc_dma_sta == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; ADC_N_CHANNEL; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ADC_BUF_SIZE / ADC_N_CHANNEL; i++)<span class="comment">/* 每个通道采集了50次数据,进行50次累加 */</span></span><br><span class="line">                &#123;</span><br><span class="line">                    sum += adc_buf[(i * ADC_N_CHANNEL) + j];<span class="comment">/* 相同通道的转换数据累加 */</span></span><br><span class="line">                &#125;</span><br><span class="line">                adcx = sum / (ADC_BUF_SIZE / ADC_N_CHANNEL);</span><br><span class="line">                lcd_show_num(<span class="number">83</span>, <span class="number">50</span>+(j*<span class="number">30</span>), adcx, <span class="number">5</span>,.color=colour[j]);</span><br><span class="line">                temp=(<span class="type">float</span> )adcx * (<span class="number">3.3</span>/<span class="number">4096</span>);</span><br><span class="line">                adcx = temp;</span><br><span class="line">                lcd_show_num(<span class="number">83</span>, <span class="number">62</span> + (j*<span class="number">30</span>), adcx, <span class="number">1</span>,.color=colour[j]);</span><br><span class="line">                temp -= adcx;</span><br><span class="line">                temp *= <span class="number">1000</span>;</span><br><span class="line">                lcd_show_num(<span class="number">95</span>, <span class="number">62</span> + (j*<span class="number">30</span>), temp, <span class="number">3</span>,.color=colour[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            adc_dma_sta = <span class="number">0</span>;</span><br><span class="line">            adc_dma_enable(ADC_BUF_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">        delay_ms(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/8b245cc2d2f542de998fbe49faf11ec8.jpeg#pic_center" alt=""></p>
<h2 id="11-6-过采集求均值提高分辨率">11.6 过采集求均值提高分辨率</h2>
<p>如果采样频率高于信号最高频率的两倍，这种采样被称为过采样。（奈奎斯特采样定理-香农采样定理）<br>
即尽可能快地采样数据，比如之前是1s采1次，现在做成100ms采1次，并把缓存10次的数据求平均。</p>
<p>而我们就能利用过采样和求均值来提高分辨率位数。</p>
<p>根据要增加的分辨率位数计算过采样频率方程：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/ec616a2b4b2a4902a911350ba8f4a725.png" alt=""><br>
fos 是过采样频率，w是希望增加的分辨率位数，fs 是初始采样频率要求</p>
<p><a target="_blank" rel="noopener" href="https://max.book118.com/html/2018/0506/165038217.shtm">方程推导过程</a></p>
<p>方法就是：<br>
过采样数据累加并移位（这一步叫求均值，但不是求总数平均值的意思）</p>
<p>举个例子：12位分辨率的ADC提高4位分辨率，采样频率就要提高256倍<br>
即需要256次采集才能得到一次16位分辨率的数据<br>
然后将这256次采集结果求和，求和的结果再右移4位，就得到提高分辨率后的结果<br>
<strong>注意：提高N 位分辨率，需要 右移N位</strong></p>
<p>按照这个原理，我们改造之前的DMA单通道实验：</p>
<p>定义DMA目标地址数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_OVERSAMPLE_N 4	<span class="comment">//过采样位数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_POWER 65536       <span class="comment">//分辨率 2^(12+ADC_OVERSAMPLE_N)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AVERAGE_TIMES 10	<span class="comment">//平均次数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_OVERSAMPLE_TIMES 256	<span class="comment">//过采样次数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_BUF_SIZE  AVERAGE_TIMES * ADC_OVERSAMPLE_TIMES</span></span><br><span class="line">u16 adc_buf[ADC_BUF_SIZE];</span><br></pre></td></tr></table></figure>
<p>编写核心代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">    u32 adcx;</span><br><span class="line">    <span class="type">float</span> temp;</span><br><span class="line">    u32 sum;</span><br><span class="line">    painter.color=BLUE;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(adc_dma_sta == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ADC_BUF_SIZE; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += adc_buf[i];<span class="comment">//将256次过采样再进行10次平均值</span></span><br><span class="line">            &#125;</span><br><span class="line">            adcx = sum / (AVERAGE_TIMES);</span><br><span class="line">            adcx &gt;&gt;= ADC_OVERSAMPLE_N;<span class="comment">//得到16位ADC数据</span></span><br><span class="line">            lcd_show_num(<span class="number">83</span>, <span class="number">50</span>, adcx, <span class="number">5</span>);</span><br><span class="line">            temp=(<span class="type">float</span> )adcx * (<span class="number">3.3</span>/N_POWER);</span><br><span class="line">            adcx = temp;</span><br><span class="line">            lcd_show_num(<span class="number">83</span>, <span class="number">62</span> , adcx, <span class="number">1</span>);</span><br><span class="line">            temp -= adcx;</span><br><span class="line">            temp *= <span class="number">1000</span>;</span><br><span class="line">            lcd_show_num(<span class="number">95</span>, <span class="number">62</span>, temp, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">            adc_dma_sta = <span class="number">0</span>;</span><br><span class="line">            adc_dma_enable(ADC_BUF_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">        delay_ms(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br></pre></td></tr></table></figure>
<p>可以看见，我们的采样值已经到达了16位的分辨率了。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/864f0cd83a7d4fd286e691a9228f3050.jpeg" alt=""></p>
<h2 id="11-7-双adc同步转换">11.7 双ADC同步转换</h2>
<p>双 ADC 的机制就是使用两个 ADC 同时采样一个或者多个通道。双重ADC 模式较独立模式一个最大的优势就是提高了采样率，弥补了单个 ADC 采样不够快的缺点。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/81c3a1f7d6d64b7d96402234d39eb22a.png#pic_center" alt=""><br>
这里也说了昂，需要使能DMA模式。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20685b56e6ac4c5f8dfcddc4833a4583.png#pic_center" alt=""><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/a516acfa0c39491484f542286f5512a9.png#pic_center" alt=""><br>
详情可以参考：<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42033458/article/details/113068640">STM32之双ADC详解</a></p>
<p>例如：我们使用ADC1、ADC2同步采集，让ADC1采集内部参考电压、ADC2采集外部模拟电压。<br>
这里我们选择：<br>
Dual regular simultaneous mode only （规则同步转换模式）<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/81a0c2c949fc45a4abf7038e9eaddfa6.png#pic_center" alt=""><br>
我们选择用定时器触发ADC<br>
配置好TIM3，并触发事件设置为Update Event，也就是把UEV事件信号作为TRGO信号。这样ADC在TIM3的TRGO信号每个上升沿启动一次ADC转换。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/d72dd82fe74e4792966f4f53ddbcc67a.png#pic_center" alt=""><br>
接着配置通道：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/2e2cf77f5e3142cfac769f1e74613500.png#pic_center" alt=""><br>
ADC2的通道和ADC1保持一致，避免不同步：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/30e375afd3e44b86a54c95ac9cdc29fc.png#pic_center" alt=""><br>
因为共用ADC通道，这里DMA要更改为32位数据宽度：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/a4e17050129a4718a1a5ba50285e32b4.png#pic_center" alt=""></p>
<p>生成工程：</p>
<p>因为没有开启连续模式，我们的DMA缓存数组大小为1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_BUF_SIZE  1</span></span><br><span class="line">u32 adc_buf[ADC_BUF_SIZE];</span><br></pre></td></tr></table></figure>
<p>先打开ADC2，使能ADC1同步模式，打开定时器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_ADC_Start(&amp;hadc2);</span><br><span class="line">HAL_ADCEx_MultiModeStart_DMA(&amp;hadc1, adc_buf, ADC_BUF_SIZE);</span><br><span class="line">HAL_TIM_Base_Start(&amp;htim3);</span><br></pre></td></tr></table></figure>
<p>这里笔者偷个懒，直接显示结果（求均值占时间比较大，应该采用之前的方法，在main函数里进行）</p>
<p>编写回调函数（DMA传输完成进入中断服务函数进而会调用ADC传输完成函数）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_ADC_ConvCpltCallback</span><span class="params">(ADC_HandleTypeDef *hadc)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 volt;</span><br><span class="line">    u32 value = adc_buf[<span class="number">0</span>];</span><br><span class="line">    u32 adc1_value = value &amp; <span class="number">0x0000FFFF</span>;<span class="comment">//低16位是ADC1</span></span><br><span class="line">    volt = <span class="number">3300</span> *adc1_value;</span><br><span class="line">    volt &gt;&gt;= <span class="number">12</span> ;<span class="comment">//除以2^12</span></span><br><span class="line">    lcd_show_num(<span class="number">100</span>,<span class="number">50</span>,volt,<span class="number">4</span>);</span><br><span class="line">    u32 adc2_value = value &amp; <span class="number">0xFFFF0000</span>;<span class="comment">//高16位是ADC2</span></span><br><span class="line">    volt = <span class="number">3300</span> *adc2_value;</span><br><span class="line">    volt &gt;&gt;= <span class="number">12</span> ;<span class="comment">//除以2^12</span></span><br><span class="line">    lcd_show_num(<span class="number">100</span>,<span class="number">62</span>,volt,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="12-dac">12 DAC</h1>
<p>之前说过ADC和DAC是模拟电路与数字电路之间的桥梁<br>
那么，有了ADC（Analog-to-Digital Converter），那就有DAC，Digital-to-Analog Converter</p>
<h2 id="12-1-走进dac">12.1 走进DAC</h2>
<p>DAC能将数字量转化为模拟量，从而和ADC构成系统：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/6c17d63884334927afa8b2f264d5bdb6.png" alt=""><br>
基本参数依旧是那些东西：<br>
分辨率、参考电压、供电电压、输出通道啥的：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/e9ee4718c82d4780bf197def79d9222c.png" alt=""></p>
<h2 id="12-2-dac配置">12.2 DAC配置</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/f4bff68c9f21419fb286ad7394773268.png#pic_center" alt=""><br>
<strong>数据格式</strong><br>
DAC数据格式：支持8/12位模式<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/af8cb54418554345b5144d0c129bb964.png" alt=""><br>
后面笔者将用单通道12位右对齐进行演示</p>
<p>单通道独立输出时用的是：DAC_DHR8Rx、DAC_DHR12Rx、DAC_DHR12Lx</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/653b37b97edd4ce9b5eafb7a0d434835.png" alt=""><br>
双通道同时输出时，会启用共同寄存器：DAC_DHR8RD、DAC_DHR12RD、DAC_DHR12LD</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/382c4e363e3f411cabb9fa04c4823bb4.png" alt=""></p>
<p><strong>触发源</strong><br>
三种触发转换的方式：自动触发、软件触发、外部事件触发<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/a77ee6236aa849de9e2d0bde4d0a9d52.png#pic_center" alt=""><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/d5a6551d312e4f1aad3cb456f706079b.png#pic_center" alt=""></p>
<p><strong>噪声波和三角波</strong><br>
DAC内部使用线性反馈移位寄存器，可以生成变振幅的伪噪声，每次发生触发时，经过3个APB1时钟周期后，LFSR生成一个随机数并移入DOR。<br>
注意，生成噪声波和三角波，必须使用外部触发。</p>
<h2 id="12-3-dac输出电压">12.3 DAC输出电压</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/63b4e0de83bc426e8a03eb92b052fe96.png#pic_center" alt=""></p>
<p>OutPut Buffer：设置是否使用输出缓冲器。使用的话，可以降低输出阻抗，提高输出负载能力，默认Enable。<br>
Trigger：外部触发信号源。本次不使用外部触发，设置为None。</p>
<p>软件触发不等于None：<br>
如果是None, 那么不需要其他任何的触发源，直接<code>HAL_DAC_SetValue()</code>设置DAC的值,就可以设定输出电压的大小。如果使用了软件触发，那么，每次在使用<code>HAL_DAC_SetValue()</code>修改输出电压后，还需要调用使能,目的是使能软件触发。由于：软件触发是硬件在一个APB1时钟周期后自动关断的，于是，每次修改输出电压的值后，都要调用软件使能的方法，才能生效。</p>
<p>可以参考：<br>
<a target="_blank" rel="noopener" href="https://shequ.stmicroelectronics.cn/thread-619723-1-1.html">DAC 使用软件触发，无电压输出</a><br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/cjyc/p/6656853.html">STM32_DAC之软件触发（Trigger）</a></p>
<p>我们生成工程：</p>
<p>编写电压设置函数：</p>
<p>选择通道，对齐方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vol:0-3300</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dac_set_voltage</span><span class="params">(u16 vol)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> temp = vol;</span><br><span class="line">    temp /= <span class="number">1000</span>;</span><br><span class="line">    temp = temp * <span class="number">4096</span> / <span class="number">3.3</span>;</span><br><span class="line">    <span class="keyword">if</span>(temp &gt;= <span class="number">4096</span>) temp = <span class="number">4095</span>;</span><br><span class="line">    HAL_DAC_SetValue(&amp;hdac, DAC_CHANNEL_1, DAC_ALIGN_12B_R, temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着拿之前写的ADC测一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">	dac_set_voltage(<span class="number">1500</span>);</span><br><span class="line">    u32 adcx;</span><br><span class="line">    <span class="type">float</span> temp;</span><br><span class="line">    u32 sum;</span><br><span class="line">    painter.color=BLUE;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(adc_dma_sta == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ADC_BUF_SIZE; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += adc_buf[i];</span><br><span class="line">            &#125;</span><br><span class="line">            adcx = sum / (AVERAGE_TIMES);</span><br><span class="line">            lcd_show_num(<span class="number">83</span>, <span class="number">50</span>, adcx, <span class="number">5</span>);</span><br><span class="line">            temp=(<span class="type">float</span> )adcx * (<span class="number">3.3</span>/<span class="number">4096</span>);</span><br><span class="line">            adcx = temp;</span><br><span class="line">            lcd_show_num(<span class="number">83</span>, <span class="number">62</span> , adcx, <span class="number">1</span>);</span><br><span class="line">            temp -= adcx;</span><br><span class="line">            temp *= <span class="number">1000</span>;</span><br><span class="line">            lcd_show_num(<span class="number">95</span>, <span class="number">62</span>, temp, <span class="number">3</span>);</span><br><span class="line">            adc_dma_sta = <span class="number">0</span>;</span><br><span class="line">            adc_dma_enable(ADC_BUF_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">        delay_ms(<span class="number">100</span>);</span><br><span class="line"><span class="comment">/* USER CODE END WHILE */</span></span><br></pre></td></tr></table></figure>
<p>就可以自行查看结果了。</p>
<h2 id="12-3-dac直接输出三角波">12.3 DAC直接输出三角波</h2>
<p>输出三角波<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/26e1c684c1ae4746a886141a0f8687b4.png#pic_center" alt=""><br>
不满足取值范围，波形不完整</p>
<p>编写对应代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//maxval:    幅值：0 &lt; maxval &lt; 4096, (maxval + 1) &gt;= samples/2</span></span><br><span class="line"><span class="comment">//dt:        delay_us 小于5us后不精确</span></span><br><span class="line"><span class="comment">//samples:   采样点sample个</span></span><br><span class="line"><span class="comment">//n:         输出波形的次数(0~65535)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dac_triangular_wave</span><span class="params">(u16 maxval, u16 dt, u16 samples, u16 n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> incval;</span><br><span class="line">    <span class="type">float</span> curval;</span><br><span class="line">    <span class="keyword">if</span>(samples &gt; ((maxval + <span class="number">1</span>) * <span class="number">2</span>))    <span class="keyword">return</span>;</span><br><span class="line">    incval = (maxval + <span class="number">1</span>) / (samples / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(u16 j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        curval = <span class="number">0</span>;</span><br><span class="line">        HAL_DAC_SetValue(&amp;DAC_HANDLE, channel, DAC_ALIGN_12B_R, curval);</span><br><span class="line">        <span class="keyword">for</span>(u16 i = <span class="number">0</span>; i &lt; (samples/<span class="number">2</span>); i++)    <span class="comment">//上升波</span></span><br><span class="line">        &#123;</span><br><span class="line">            curval += incval;</span><br><span class="line">            HAL_DAC_SetValue(&amp;DAC_HANDLE, channel, DAC_ALIGN_12B_R, curval);</span><br><span class="line">            delay_us(dt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(u16 i = <span class="number">0</span>; i &lt; (samples/<span class="number">2</span>); i++)    <span class="comment">//下降波</span></span><br><span class="line">        &#123;</span><br><span class="line">            curval -= incval;</span><br><span class="line">            HAL_DAC_SetValue(&amp;DAC_HANDLE, channel, DAC_ALIGN_12B_R, curval);</span><br><span class="line">            delay_us(dt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在while里调用它：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dac_triangular_wave(<span class="number">4095</span>, <span class="number">5</span>, <span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/6eeb8c63b72b4334b9b7f9e04036a864.jpeg" alt=""></p>
<h2 id="12-4-用dma让dac输出正弦波">12.4 用DMA让DAC输出正弦波</h2>
<p>差不多的就是那些伎俩，这次用DMA把一个正弦波数组传给DAC，并让DAC输出这个正弦波。</p>
<p>选择DAC2：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/f93f66669439498abf5f751496cc321c.png#pic_center" alt=""><br>
选择TIM7作为DAC2的触发源，并配置TIM7<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/2b570e90d20e4c3c8e5254c1bd6ea0f3.png#pic_center" alt=""><br>
接着使能DMA<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/f125754bbf01470989dad3fa8af7e8d4.png#pic_center" alt=""><br>
生成工程：</p>
<p>编写为我们生成正弦波数组的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PAI 3.1415926</span></span><br><span class="line"><span class="comment">//生成正弦波数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dac_creat_sin_buf</span><span class="params">(u16 *buf, u16 maxval, u16 samples)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> outdata = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> inc = (<span class="number">2</span> * PAI) / samples;</span><br><span class="line">    <span class="keyword">if</span>(maxval &lt;= (samples / <span class="number">2</span>)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; samples; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//正弦函数解析式：y= Asin(wx + k) + b</span></span><br><span class="line">        outdata = maxval * <span class="built_in">sin</span>(inc * i) + maxval;</span><br><span class="line">        <span class="keyword">if</span> (outdata &gt; <span class="number">4095</span>)</span><br><span class="line">            outdata = <span class="number">4095</span>;</span><br><span class="line">        buf[i] = outdata;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于DMA的源地址设置函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DMA_DAC hdma_dac_ch2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DAC_HANDLE hdac</span></span><br><span class="line"><span class="keyword">extern</span> DMA_HandleTypeDef DMA_DAC;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dac_init_dma</span><span class="params">(u32 _channel, u32 _mar)</span></span><br><span class="line">&#123;</span><br><span class="line">    mar = _mar;</span><br><span class="line">    channel = _channel;</span><br><span class="line">    <span class="keyword">if</span>(channel == DAC_CHANNEL_1)</span><br><span class="line">        HAL_DMA_Start(&amp;DMA_DAC, mar, (u32)&amp;DAC_HANDLE.Instance-&gt;DHR12R1, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(channel == DAC_CHANNEL_2)</span><br><span class="line">        HAL_DMA_Start(&amp;DMA_DAC, mar, (u32)&amp;DAC_HANDLE.Instance-&gt;DHR12R2, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DMA使能函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TIM_DAC htim7</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dac_dma_enable</span><span class="params">(u16 cndtr, u16 arr, u16 psc)</span></span><br><span class="line">&#123;</span><br><span class="line">    TIM_DAC.Instance-&gt;PSC= psc;</span><br><span class="line">    TIM_DAC.Instance-&gt;ARR= arr;</span><br><span class="line">    HAL_TIM_Base_Start(&amp;TIM_DAC);</span><br><span class="line">    HAL_DAC_Stop_DMA(&amp;DAC_HANDLE, channel);</span><br><span class="line">    HAL_DAC_Start_DMA(&amp;DAC_HANDLE, channel, (u32 *)mar, cndtr, DAC_ALIGN_12B_R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通道设置函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dac_set_channel</span><span class="params">(u32 _channel)</span></span><br><span class="line">&#123;</span><br><span class="line">    channel = _channel;</span><br><span class="line">    HAL_DAC_Start(&amp;DAC_HANDLE, channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主函数中开启这一切：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u16 buf[<span class="number">4096</span>];</span><br><span class="line">dac_creat_sin_buf(buf, <span class="number">2048</span>, <span class="number">100</span>);<span class="comment">//生成正弦数组</span></span><br><span class="line">dac_init_dma(DAC_CHANNEL_2, (u32)&amp;buf);<span class="comment">//把数组给dma</span></span><br><span class="line">dac_dma_enable(<span class="number">100</span>, <span class="number">10</span><span class="number">-1</span>, <span class="number">24</span><span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/4e7aef93b1de41bb9996dc609cdd80a8.jpeg#pic_center" alt=""></p>
<p>文末，把之前用到的一部分常用的函数整理成模块,方便我们调用，当然，大家也可以自行封装更多的函数作为自己的模块。</p>
<p>ADC:</p>
<p>adclib.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Whisky on 2023/1/13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HELLOWORLD_ADCLIB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HELLOWORLD_ADCLIB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_HANDLE hadc1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DMA_ADC    hdma_adc1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 adc_dma_sta;</span><br><span class="line"></span><br><span class="line">u32 <span class="title function_">adc_get_resule_pollfor</span><span class="params">(u8 times)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">adc_dma_enable</span><span class="params">(u16 cndtr)</span>;</span><br><span class="line">u32 <span class="title function_">adc_init_dma</span><span class="params">(u32 _mar)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//HELLOWORLD_ADCLIB_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>adclib.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Whisky on 2023/1/13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;adclib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;adc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 adc_dma_sta;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> DMA_HandleTypeDef DMA_ADC;</span><br><span class="line"></span><br><span class="line">u32 <span class="title function_">adc_init_dma</span><span class="params">(u32 mar)</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_ADCEx_Calibration_Start(&amp;ADC_HANDLE);</span><br><span class="line">    HAL_DMA_Start_IT(&amp;DMA_ADC, (u32)&amp;ADC_HANDLE.Instance-&gt;DR, mar,<span class="number">0</span>);</span><br><span class="line">    HAL_ADC_Start_DMA(&amp;ADC_HANDLE, &amp;mar, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u32 _adc_get_resule_pollfor(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    HAL_ADC_Start(&amp;ADC_HANDLE);</span><br><span class="line">    HAL_ADC_PollForConversion(&amp;ADC_HANDLE, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> (u16)HAL_ADC_GetValue(&amp;ADC_HANDLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u32 <span class="title function_">adc_get_resule_pollfor</span><span class="params">(u8 times)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 temp_val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; times; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp_val += _adc_get_resule_pollfor();</span><br><span class="line">        delay_ms(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (temp_val / times);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA1_Channel1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (DMA1-&gt;ISR &amp; (<span class="number">1</span> &lt;&lt; <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        adc_dma_sta = <span class="number">1</span>;</span><br><span class="line">        DMA1-&gt;IFCR |= (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">adc_dma_enable</span><span class="params">(u16 cndtr)</span></span><br><span class="line">&#123;</span><br><span class="line">    ADC_HANDLE.Instance-&gt;CR2 &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">0</span>);                 <span class="comment">//__HAL_ADC_DISABLE(&amp;ADC_HANDLE);</span></span><br><span class="line">    DMA_ADC.Instance-&gt;CCR &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">0</span>);        <span class="comment">//__HAL_DMA_DISABLE(&amp;DMA_ADC);</span></span><br><span class="line">    <span class="keyword">while</span> (DMA_ADC.Instance-&gt;CCR &amp; (<span class="number">1</span> &lt;&lt; <span class="number">0</span>));  <span class="comment">// while (__HAL_DMA_GET_FLAG(&amp;DMA_ADC, __HAL_DMA_GET_TC_FLAG_INDEX(&amp;DMA_ADC)));</span></span><br><span class="line">    DMA_ADC.Instance-&gt;CNDTR = cndtr;</span><br><span class="line">    DMA_ADC.Instance-&gt;CCR |= (<span class="number">1</span> &lt;&lt; <span class="number">0</span>);         <span class="comment">//__HAL_DMA_ENABLE(&amp;DMA_ADC);</span></span><br><span class="line">    ADC_HANDLE.Instance-&gt;CR2 |= (<span class="number">1</span> &lt;&lt; <span class="number">0</span>);                  <span class="comment">//__HAL_ADC_ENABLE(&amp;ADC_HANDLE);</span></span><br><span class="line">    ADC_HANDLE.Instance-&gt;CR2 |= (<span class="number">1</span> &lt;&lt; <span class="number">22</span>);                 <span class="comment">//HAL_ADC_Start(&amp;ADC_HANDLE)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DAC:</p>
<p>daclib.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Whisky on 2023/1/13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HELLOWORLD_DACLIB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HELLOWORLD_DACLIB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DMA_DAC hdma_dac_ch2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DAC_HANDLE hdac</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIM_DAC htim7</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAI 3.1415926</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dac_init_dma</span><span class="params">(u32 _channel, u32 _mar)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dac_set_voltage</span><span class="params">(u16 vol)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dac_init_dma</span><span class="params">(u32 _channel, u32 _mar)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dac_triangular_wave</span><span class="params">(u16 maxval, u16 dt, u16 samples, u16 n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dac_creat_sin_buf</span><span class="params">(u16 *buf, u16 maxval, u16 samples)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dac_dma_enable</span><span class="params">(u16 cndtr, u16 arr, u16 psc)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//HELLOWORLD_DACLIB_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>daclib.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Whisky on 2023/1/13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;daclib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dac.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u32 channel ;</span><br><span class="line">u32 mar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> DMA_HandleTypeDef DMA_DAC;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dac_set_channel</span><span class="params">(u32 _channel)</span></span><br><span class="line">&#123;</span><br><span class="line">    channel = _channel;</span><br><span class="line">    HAL_DAC_Start(&amp;DAC_HANDLE, channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dac_init_dma</span><span class="params">(u32 _channel, u32 _mar)</span></span><br><span class="line">&#123;</span><br><span class="line">    mar = _mar;</span><br><span class="line">    channel = _channel;</span><br><span class="line">    <span class="keyword">if</span>(channel == DAC_CHANNEL_1)</span><br><span class="line">        HAL_DMA_Start(&amp;DMA_DAC, mar, (u32)&amp;DAC_HANDLE.Instance-&gt;DHR12R1, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(channel == DAC_CHANNEL_2)</span><br><span class="line">        HAL_DMA_Start(&amp;DMA_DAC, mar, (u32)&amp;DAC_HANDLE.Instance-&gt;DHR12R2, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//vol:0-3300</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dac_set_voltage</span><span class="params">(u16 vol)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> temp = vol;</span><br><span class="line">    temp /= <span class="number">1000</span>;</span><br><span class="line">    temp = temp * <span class="number">4096</span> / <span class="number">3.3</span>;</span><br><span class="line">    <span class="keyword">if</span>(temp &gt;= <span class="number">4096</span>) temp = <span class="number">4095</span>;</span><br><span class="line">    HAL_DAC_SetValue(&amp;DAC_HANDLE, channel, DAC_ALIGN_12B_R, temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//maxval:    幅值：0 &lt; maxval &lt; 4096, (maxval + 1) &gt;= samples/2</span></span><br><span class="line"><span class="comment">//dt:        delay_us 小于5us后不精确</span></span><br><span class="line"><span class="comment">//samples:   采样点sample个</span></span><br><span class="line"><span class="comment">//n:         输出波形的次数(0~65535)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dac_triangular_wave</span><span class="params">(u16 maxval, u16 dt, u16 samples, u16 n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> incval;</span><br><span class="line">    <span class="type">float</span> curval;</span><br><span class="line">    <span class="keyword">if</span>(samples &gt; ((maxval + <span class="number">1</span>) * <span class="number">2</span>))    <span class="keyword">return</span>;</span><br><span class="line">    incval = (maxval + <span class="number">1</span>) / (samples / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(u16 j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        curval = <span class="number">0</span>;</span><br><span class="line">        HAL_DAC_SetValue(&amp;DAC_HANDLE, channel, DAC_ALIGN_12B_R, curval);</span><br><span class="line">        <span class="keyword">for</span>(u16 i = <span class="number">0</span>; i &lt; (samples/<span class="number">2</span>); i++)    <span class="comment">//上升波</span></span><br><span class="line">        &#123;</span><br><span class="line">            curval += incval;</span><br><span class="line">            HAL_DAC_SetValue(&amp;DAC_HANDLE, channel, DAC_ALIGN_12B_R, curval);</span><br><span class="line">            delay_us(dt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(u16 i = <span class="number">0</span>; i &lt; (samples/<span class="number">2</span>); i++)    <span class="comment">//下降波</span></span><br><span class="line">        &#123;</span><br><span class="line">            curval -= incval;</span><br><span class="line">            HAL_DAC_SetValue(&amp;DAC_HANDLE, channel, DAC_ALIGN_12B_R, curval);</span><br><span class="line">            delay_us(dt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成正弦波数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dac_creat_sin_buf</span><span class="params">(u16 *buf, u16 maxval, u16 samples)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> outdata = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> inc = (<span class="number">2</span> * PAI) / samples;</span><br><span class="line">    <span class="keyword">if</span>(maxval &lt;= (samples / <span class="number">2</span>)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; samples; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//正弦函数解析式：y= Asin(wx + k) + b</span></span><br><span class="line">        outdata = maxval * <span class="built_in">sin</span>(inc * i) + maxval;</span><br><span class="line">        <span class="keyword">if</span> (outdata &gt; <span class="number">4095</span>)</span><br><span class="line">            outdata = <span class="number">4095</span>;</span><br><span class="line">        buf[i] = outdata;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dac_dma_enable</span><span class="params">(u16 cndtr, u16 arr, u16 psc)</span></span><br><span class="line">&#123;</span><br><span class="line">    TIM_DAC.Instance-&gt;PSC= psc;</span><br><span class="line">    TIM_DAC.Instance-&gt;ARR= arr;</span><br><span class="line">    HAL_TIM_Base_Start(&amp;TIM_DAC);</span><br><span class="line">    HAL_DAC_Stop_DMA(&amp;DAC_HANDLE, channel);</span><br><span class="line">    HAL_DAC_Start_DMA(&amp;DAC_HANDLE, channel, (u32 *)mar, cndtr, DAC_ALIGN_12B_R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://rich-blog.cn">瑞奇</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rich-blog.cn/2023/01/17/STM32/ADC%E5%92%8CDAC%E2%80%94%E2%80%94%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99STM32(%E7%AC%AC%E4%B9%9D%E6%9C%9F)/">https://rich-blog.cn/2023/01/17/STM32/ADC%E5%92%8CDAC%E2%80%94%E2%80%94%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99STM32(%E7%AC%AC%E4%B9%9D%E6%9C%9F)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rich-blog.cn" target="_blank">瑞奇的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/stm32/">stm32</a><a class="post-meta__tags" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/">单片机</a><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><a class="post-meta__tags" href="/tags/c%E8%AF%AD%E8%A8%80/">c语言</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/26/C++/cpp_1/" title="变量和基本类型——跟我一起从C到C++(第一期)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">变量和基本类型——跟我一起从C到C++(第一期)</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/15/STM32/%E2%80%9C1%EF%BC%8C2%EF%BC%8C3%EF%BC%8C%E5%AE%9A%E6%97%B6%E5%99%A8%E2%80%9D%E2%80%94%E2%80%94%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99STM32(%E7%AC%AC%E5%85%AB%E6%9C%9F)/" title="“1，2，3，定时器”——跟我一起写STM32(第八期)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">“1，2，3，定时器”——跟我一起写STM32(第八期)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/11/STM32/OLED(%E5%90%ABIIC)%E2%80%94%E2%80%94%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99STM32(%E7%AC%AC%E5%85%AD%E6%9C%9F)/" title="OLED(含IIC)——跟我一起写STM32(第六期)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-11</div><div class="title">OLED(含IIC)——跟我一起写STM32(第六期)</div></div></a></div><div><a href="/2023/01/10/STM32/%E5%90%AF%E8%88%AA%E2%80%94%E2%80%94%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99STM32(%E7%AC%AC%E4%B8%80%E6%9C%9F)/" title="启航——跟我一起写STM32(第一期)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/10.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-10</div><div class="title">启航——跟我一起写STM32(第一期)</div></div></a></div><div><a href="/2023/01/12/STM32/LCD(%E5%90%ABFSMC)%E2%80%94%E2%80%94%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99STM32(%E7%AC%AC%E4%B8%83%E6%9C%9F)/" title="LCD(含FSMC)——跟我一起写STM32(第七期)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-12</div><div class="title">LCD(含FSMC)——跟我一起写STM32(第七期)</div></div></a></div><div><a href="/2023/01/15/STM32/%E2%80%9C1%EF%BC%8C2%EF%BC%8C3%EF%BC%8C%E5%AE%9A%E6%97%B6%E5%99%A8%E2%80%9D%E2%80%94%E2%80%94%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99STM32(%E7%AC%AC%E5%85%AB%E6%9C%9F)/" title="“1，2，3，定时器”——跟我一起写STM32(第八期)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">“1，2，3，定时器”——跟我一起写STM32(第八期)</div></div></a></div><div><a href="/2023/01/10/STM32/%E6%8C%89%E4%B8%8B%E6%8C%89%E9%94%AE(%E5%90%ABEXTI)%E2%80%94%E2%80%94%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99STM32(%E7%AC%AC%E5%9B%9B%E6%9C%9F)/" title="按下按键(含EXTI)——跟我一起写STM32(第四期)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/11.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-10</div><div class="title">按下按键(含EXTI)——跟我一起写STM32(第四期)</div></div></a></div><div><a href="/2023/01/11/STM32/%E4%B8%B2%E5%8F%A3(%E5%90%ABDMA)%E2%80%94%E2%80%94%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99STM32(%E7%AC%AC%E4%BA%94%E6%9C%9F)/" title="串口(含DMA)——跟我一起写STM32(第五期)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-11</div><div class="title">串口(含DMA)——跟我一起写STM32(第五期)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/pearl.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">瑞奇</div><div class="author-info__description">一个心怀浪漫的少年</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://blog.csdn.net/DreamTrue520?spm=1011.2124.3001.5343"><i></i><span>🛴前往小家...</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/info/wechat" target="_blank" title="WeChat"><i class="fab fa-weixin"></i></a><a class="social-icon" href="/info/qq" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="https://github.com/mico845" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1120845871@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95"><span class="toc-text">文章目录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-adc"><span class="toc-text">11 ADC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-%E8%B5%B0%E8%BF%9Badc"><span class="toc-text">11.1 走进ADC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-adc%E9%85%8D%E7%BD%AE"><span class="toc-text">11.2 ADC配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-1-%E6%8E%92%E9%98%9F%E9%97%AE%E9%A2%98"><span class="toc-text">11.2.1 排队问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-2-%E8%A7%A6%E5%8F%91%E6%BA%90"><span class="toc-text">11.2.2 触发源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-3-%E8%BD%AC%E6%8D%A2%E6%97%B6%E9%97%B4"><span class="toc-text">11.2.3 转换时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-4-%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90"><span class="toc-text">11.2.4 数据对齐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-5-adc%E6%A8%A1%E5%BC%8F"><span class="toc-text">11.2.5 ADC模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-adc%E8%BD%AE%E8%AF%A2%E9%87%87%E9%9B%86"><span class="toc-text">11.3 ADC轮询采集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4-%E7%94%A8%E4%B8%8Adma%E4%BC%A0%E8%BE%93adc"><span class="toc-text">11.4 用上DMA传输ADC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-5-%E5%A4%9A%E9%80%9A%E9%81%93%E9%87%87%E9%9B%86"><span class="toc-text">11.5 多通道采集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-6-%E8%BF%87%E9%87%87%E9%9B%86%E6%B1%82%E5%9D%87%E5%80%BC%E6%8F%90%E9%AB%98%E5%88%86%E8%BE%A8%E7%8E%87"><span class="toc-text">11.6 过采集求均值提高分辨率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-7-%E5%8F%8Cadc%E5%90%8C%E6%AD%A5%E8%BD%AC%E6%8D%A2"><span class="toc-text">11.7 双ADC同步转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-dac"><span class="toc-text">12 DAC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-%E8%B5%B0%E8%BF%9Bdac"><span class="toc-text">12.1 走进DAC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-dac%E9%85%8D%E7%BD%AE"><span class="toc-text">12.2 DAC配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-dac%E8%BE%93%E5%87%BA%E7%94%B5%E5%8E%8B"><span class="toc-text">12.3 DAC输出电压</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-dac%E7%9B%B4%E6%8E%A5%E8%BE%93%E5%87%BA%E4%B8%89%E8%A7%92%E6%B3%A2"><span class="toc-text">12.3 DAC直接输出三角波</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-4-%E7%94%A8dma%E8%AE%A9dac%E8%BE%93%E5%87%BA%E6%AD%A3%E5%BC%A6%E6%B3%A2"><span class="toc-text">12.4 用DMA让DAC输出正弦波</span></a></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 瑞奇</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>