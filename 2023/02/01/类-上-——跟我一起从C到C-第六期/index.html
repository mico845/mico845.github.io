<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>类(上)——跟我一起从C到C++(第六期) | 瑞奇的博客</title><meta name="author" content="瑞奇"><meta name="copyright" content="瑞奇"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="文章目录  8 类  8.1 定义抽象数据类型  8.1.1 结构体？类？ 8.1.2 定义成员函数  8.1.2.1 this指针 8.1.2.2 const成员函数 8.1.2.3 类作用域 8.1.2.4 在类外定义成员函数  8.1.2.4.1 作用域运算符 8.1.2.4.2 定义一个返回this对象的函数       8.2 定义类相关的非成员函数  8.2.1 定义read和pri">
<meta property="og:type" content="article">
<meta property="og:title" content="类(上)——跟我一起从C到C++(第六期)">
<meta property="og:url" content="https://rich-blog.cn/2023/02/01/%E7%B1%BB-%E4%B8%8A-%E2%80%94%E2%80%94%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E4%BB%8EC%E5%88%B0C-%E7%AC%AC%E5%85%AD%E6%9C%9F/index.html">
<meta property="og:site_name" content="瑞奇的博客">
<meta property="og:description" content="文章目录  8 类  8.1 定义抽象数据类型  8.1.1 结构体？类？ 8.1.2 定义成员函数  8.1.2.1 this指针 8.1.2.2 const成员函数 8.1.2.3 类作用域 8.1.2.4 在类外定义成员函数  8.1.2.4.1 作用域运算符 8.1.2.4.2 定义一个返回this对象的函数       8.2 定义类相关的非成员函数  8.2.1 定义read和pri">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://rich-blog.cn/img/cover/5.jpg">
<meta property="article:published_time" content="2023-02-01T14:20:04.000Z">
<meta property="article:modified_time" content="2023-02-13T09:14:09.085Z">
<meta property="article:author" content="瑞奇">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rich-blog.cn/img/cover/5.jpg"><link rel="shortcut icon" href="/img/panda.png"><link rel="canonical" href="https://rich-blog.cn/2023/02/01/%E7%B1%BB-%E4%B8%8A-%E2%80%94%E2%80%94%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E4%BB%8EC%E5%88%B0C-%E7%AC%AC%E5%85%AD%E6%9C%9F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '类(上)——跟我一起从C到C++(第六期)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-13 17:14:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/pearl.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover/5.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="瑞奇的博客"><span class="site-name">瑞奇的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">类(上)——跟我一起从C到C++(第六期)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-01T14:20:04.000Z" title="发表于 2023-02-01 22:20:04">2023-02-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-13T09:14:09.085Z" title="更新于 2023-02-13 17:14:09">2023-02-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E4%BB%8EC%E5%88%B0C/">跟我一起从C到C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="类(上)——跟我一起从C到C++(第六期)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><span id="more"></span>
<h3 id="文章目录">文章目录</h3>
<ul>
<li><a href="#8-%E7%B1%BB">8 类</a>
<ul>
<li><a href="#81-%E5%AE%9A%E4%B9%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">8.1 定义抽象数据类型</a>
<ul>
<li><a href="#811-%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB">8.1.1 结构体？类？</a></li>
<li><a href="#812-%E5%AE%9A%E4%B9%89%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">8.1.2 定义成员函数</a>
<ul>
<li><a href="#8121-this%E6%8C%87%E9%92%88">8.1.2.1 this指针</a></li>
<li><a href="#8122-const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">8.1.2.2 const成员函数</a></li>
<li><a href="#8123-%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F">8.1.2.3 类作用域</a></li>
<li><a href="#8124-%E5%9C%A8%E7%B1%BB%E5%A4%96%E5%AE%9A%E4%B9%89%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">8.1.2.4 在类外定义成员函数</a>
<ul>
<li><a href="#81241-%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%BF%90%E7%AE%97%E7%AC%A6">8.1.2.4.1 作用域运算符</a></li>
<li><a href="#81242-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E8%BF%94%E5%9B%9Ethis%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0">8.1.2.4.2 定义一个返回this对象的函数</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#82-%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">8.2 定义类相关的非成员函数</a>
<ul>
<li><a href="#821-%E5%AE%9A%E4%B9%89read%E5%92%8Cprint%E5%87%BD%E6%95%B0">8.2.1 定义read和print函数</a></li>
<li><a href="#822-%E5%AE%9A%E4%B9%89add%E5%87%BD%E6%95%B0">8.2.2 定义add函数</a></li>
</ul>
</li>
<li><a href="#83-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">8.3 构造函数</a>
<ul>
<li><a href="#831-%E5%90%88%E6%88%90%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">8.3.1 合成的默认构造函数</a></li>
<li><a href="#832-%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">8.3.2 定义构造函数</a>
<ul>
<li><a href="#8321-default%E7%9A%84%E5%90%AB%E4%B9%89">8.3.2.1 default的含义</a></li>
<li><a href="#8322-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%80%BC%E5%88%97%E8%A1%A8">8.3.2.2 构造函数初始值列表</a></li>
<li><a href="#8323-%E5%9C%A8%E7%B1%BB%E5%A4%96%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">8.3.2.3 在类外定义构造函数</a></li>
</ul>
</li>
<li><a href="#833-%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E5%92%8C%E6%9E%90%E6%9E%84">8.3.3 拷贝、赋值和析构</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="8-类">8 类</h1>
<p>类的基本思想是data abstraction（数据抽象）和encapsulation（封装）。<br>
数据抽象是一种依赖于接口和实现分离的编程（以及设计）技术。<br>
类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的那些各种私有函数。<br>
而封装实现了类的接口和实现的函数分离。封装之后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。</p>
<p>这样子，我们在编程中就扮演了不同的角色。这里说的用户就是另外一个程序员，他要使用你所设计并实现的类。你最好把他想成一个编程小白，非常笨那种，你要把你设计的接口尽可能易于使用，让我们使用类的时候，仅仅只需抽象地思考类型做什么，而不去顾及类的实现机理。作为一个设计良好的类，既要有直观且易于使用的接口，也要有高效的实现过程。</p>
<p>而类要实现数据的抽象和封装，就必须首先定义一个抽象数据类型。</p>
<h2 id="8-1-定义抽象数据类型">8.1 定义抽象数据类型</h2>
<p>按照刚刚学习到的小知识，我们来设计一个类<code>Sales_data</code>解决书店销售问题，它的接口包含：</p>
<ul>
<li>一个<code>id</code>成员函数，返回书的编号</li>
<li>一个<code>combine</code>成员函数，用于把一个<code>Sales_data</code>对象加到另一个对象上</li>
<li>一个名为<code>add</code>的函数，执行两个<code>Sales_data</code>对象的加法</li>
<li>一个名为<code>read</code>的函数，将数据从istream读入<code>Sales_data</code>对象中</li>
<li>一个名为<code>print</code>的函数，将<code>Sales_data</code>对象的值输入到ostream</li>
</ul>
<h3 id="8-1-1-结构体？类？">8.1.1 结构体？类？</h3>
<p>在C++语言中，结构体<code>struct</code>也有了新名字，类。<br>
我们的类由<code>struct</code>开始，紧跟着类名和类体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> unit_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct</code>里面其实不止是可以放变量，也可以放函数。<br>
在面对对象程序设计中，我们常常称变量是该类的属性，函数是它所拥有的方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">    <span class="comment">//成员函数</span></span><br><span class="line">    <span class="function">std::string <span class="title">id</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span> <span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//数据成员</span></span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> unit_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//非Sales_data的成员函数</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;, Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>尽管所有函数都必须在类的内部声明，但成员函数体可以定义在类内也可以定义在类外。对于我们的<code>Sales_data</code>类来说，<code>id</code>定义在了类内，而<code>combine</code>和<code>avg_price</code>定义在了类外。（目前代码未放出）</p>
<p>而且，定义在类内部的函数都是隐式的inline函数。</p>
<h3 id="8-1-2-定义成员函数">8.1.2 定义成员函数</h3>
<p>相必朋友们已经迷惑重重了，这个<code>return bookNo</code>，但这个成员函数<code>id</code>是怎么获得数据成员<code>bookNo</code>所依赖的对象的呢？这个奇怪的<code>const</code>怎么加在函数的形参列表后面呢？<br>
别急，我们慢慢说…</p>
<h4 id="8-1-2-1-this指针">8.1.2.1 this指针</h4>
<p>我们像使用结构体一样使用类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_data total;</span><br><span class="line">   total.<span class="built_in">id</span>();</span><br></pre></td></tr></table></figure>
<p>我们依旧使用<code>.</code>符号来访问<code>total</code>的<code>id</code>成员，方式和结构体的访问如出一辙。<br>
当我们调用成员函数的时候，实际上是在替某个对象调用它。如果<code>id</code>指向<code>Sales_data</code>的成员<code>bookNo</code>，则它隐式地指向了该函数的对象的成员。就比如刚刚的例子，我们<code>return bookNo</code>，实际上就是<code>return total.bookNo</code>。<br>
成员函数通过一个名叫<code>this</code>的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数的时候，用请求该函数的对象的地址来初始化<code>this</code>。比如刚刚的例子，我们调用<code>total.id()</code>，则编译器负责把<code>total</code>的地址传递给<code>id</code>的隐式形参<code>this</code>，可以等价地认为编译器做了以下的改写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::<span class="built_in">id</span>(&amp;total);</span><br></pre></td></tr></table></figure>
<p>在调用<code>id</code>成员时传入了<code>total</code>的地址。<br>
而我们为毛可以直接使用调用该函数的对象的成员，就是因为这个<code>this</code>所指向的就是这个对象。我们返回<code>bookNo</code>实际上就是返回的<code>this-&gt;bookNo</code>。这一切，都被隐式地省略了而已。<br>
而且这个<code>this</code>是真实存在的，它是一个常量指针。我们定义的变量不能与它重名，而且我们也能使用它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">id</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-1-2-2-const成员函数">8.1.2.2 const成员函数</h4>
<p><code>id</code>函数另一个关键之处就是它紧跟在形参列表后面的<code>const</code>关键字，这里，<code>const</code>的作用是修改隐式<code>this</code>指针的类型。<br>
默认情况下。<code>this</code>的类型是指向类类型非常量版本的常量指针。例如在<code>Sales_data</code>的成员函数中，<code>this</code>的类型就是<code>Sales_data * const</code>。（这是一个顶层const）尽管<code>this</code>是隐式的，但它依旧要经历初始化规则，意味着我们不能把<code>this</code>绑定在一个常量对象上，这一情况就使得我们不能在常量对象上调用这个成员函数（常量对象，以及常量对象的引用或指针都只能调用常量成员函数，非常量对象则可被隐式地转换）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">id</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo; &#125;<span class="comment">//不加const</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Sales_data trans;</span><br><span class="line">   trans.<span class="built_in">id</span>();<span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: passing <span class="string">&#x27;const Sales_data&#x27;</span> as <span class="string">&#x27;this&#x27;</span> argument discards qualifiers [-fpermissive]</span><br></pre></td></tr></table></figure>
<p>而在<code>id</code>函数中我们不会改变<code>this</code>所指的对象，于是我们可以把<code>this</code>设置为指向常量的指针有助于函数的灵活性。<br>
在C++中，允许把<code>const</code>关键字加在成员函数的形参列表之后，此时，紧跟在形参列表的<code>const</code>表示<code>this</code>是一个指向常量的常量指针（<code>const Sales_data * const</code>）。这样的成员函数也叫常量成员函数。</p>
<h4 id="8-1-2-3-类作用域">8.1.2.3 类作用域</h4>
<p>类的本身就是一个作用域，类的成员定义在嵌套在类的作用域里，因此<code>id</code>中用到的<code>bookNo</code>其实是定义在<code>Sales_data</code>内的数据成员。<br>
而且，值得注意的是，即使在<code>bookNo</code>定义在<code>id</code>之后，<code>id</code>还是能使用<code>bookNo</code>。这是因为，编译器分两步处理类：</p>
<ol>
<li>编译成员的声明</li>
<li>编译成员函数体（如果有的话）</li>
</ol>
<p>因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。</p>
<h4 id="8-1-2-4-在类外定义成员函数">8.1.2.4 在类外定义成员函数</h4>
<h5 id="8-1-2-4-1-作用域运算符">8.1.2.4.1 作用域运算符</h5>
<p>在类内我们声明了函数，在类外我们就要定义它（在类内定义就是隐式的inline函数）。<br>
定义方法很简单，在它的函数名前，添加一个所属类名和作用域运算符<code>::</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Sales_data::avg_price</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (unit_sold)</span><br><span class="line">        <span class="keyword">return</span> revenue/unit_sold;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>意为：我们声明<code>avg_price</code>函数，而且该函数在<code>Sales_data</code>作用域内。<br>
一旦编译器看见这个函数名，就能理解剩余代码是位于类的作用域了。<br>
当<code>avg_price</code>使用<code>revenue</code>和<code>unit_sold</code>，实际上也是隐式地使用了<code>Sales_data</code>内的成员。</p>
<h5 id="8-1-2-4-2-定义一个返回this对象的函数">8.1.2.4.2 定义一个返回this对象的函数</h5>
<p>函数<code>combine</code>的设计初衷类似<code>+=</code>，调用该函数的对象代表<code>+=</code>的左侧运算对象，而右侧运算对象则是通过显式的实参传入函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data&amp; <span class="title">Sales_data::combine</span><span class="params">(<span class="type">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unit_sold += rhs.unit_sold;</span><br><span class="line">    revenue += rhs.unit_sold;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们进行交易时就执行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_data total, trans;</span><br><span class="line">   total.<span class="built_in">combine</span>(trans);</span><br></pre></td></tr></table></figure>
<p>好神奇！一句话就更新了<code>total</code>当前的值。<br>
我们来试图解读一下：<br>
<code>total</code>的地址被绑定到隐式的<code>this</code>参数上，而<code>rhs</code>绑定到了<code>trans</code>上。（这里使用引用来进行绑定，是因为类的大小不确定，防止过大内存拷贝浪费过多）<br>
我们直接使用<code>Sales_data</code>的成员相当于都是隐式地使用了<code>this-&gt;</code>，代表的是调用这个成员函数的对象<code>total</code>的成员。而其他对象的成员则需要<code>rhs.</code>来表示。</p>
<p>该函数还有个值得注意的部分，就是它的返回类型和返回语句。<br>
一般来说，当我们定义函数类似于某个内置运算符时（刚刚的例子是模仿<code>+=</code>），应该令函数的行为尽量模仿这个运算符。而<code>+=</code>把它的运算对象当成左值返回。为了和它保持一致，函数<code>combine</code>就设计为返回引用类型。因此，此时的左侧运算对象是一个<code>Sales_data</code>的对象，则返回类型为<code>Sales_data &amp;</code>。<br>
而<code>this</code>指针的解引用就是该对象。故刚刚的例子返回的是<code>total</code>。（只是我们刚刚只执行了<code>total.combine(trans);</code>，并没有用上返回值）</p>
<h2 id="8-2-定义类相关的非成员函数">8.2 定义类相关的非成员函数</h2>
<p>类的作者常常需要定义一些辅助函数，如<code>add</code>、<code>read</code>、<code>print</code>等。尽管这些函数定义的操作从概念上应该属于类的接口的组成部分，但它们并不属于类本身。<br>
如果函数的概念上属于类，但并没有在类中声明，那它的声明（而非定义）也应该与类的声明在同一头文件。<br>
假如你是使用的CLion，在项目中添加源文件和头文件需要改写CMakeLists，这里就为你介绍其中一种方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">file</span>(   GLOB SOURCES</span><br><span class="line">        Sales_data.cpp Sales_data.h</span><br><span class="line">)</span><br><span class="line"><span class="built_in">add_executable</span>(项目名称 main.cpp $&#123;SOURCE_FILE&#125; $&#123;SOURCES&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="8-2-1-定义read和print函数">8.2.1 定义read和print函数</h3>
<p>我们定义<code>read</code>函数，输入书籍编号，售出总数，售出价格：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std::istream &amp;is, Sales_data &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.unit_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price * item.unit_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着在让<code>print</code>函数打印相关信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream &amp;os, <span class="type">const</span> Sales_data &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; item.<span class="built_in">id</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.unit_sold &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">       &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.<span class="built_in">avg_price</span>();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>read</code>函数从给定流中将数据读到给定对象中，<code>print</code>函数则负责将给定对象的内容打印到给定的流中。<br>
<code>read</code>和<code>print</code>函数分别接受一个各自的IO类型引用作为其参数，因为IO类型属于不可拷贝类型，故只能通过引用来传递它们。而且，读取和写入均会改变流的内容，故，两个函数引用均为非常量引用。<br>
（<code>print</code>函数不负责换行：一般来说，执行输出任务的函数应该尽量减少对格式的控制，确保由用户代码来决定是否换行）</p>
<h3 id="8-2-2-定义add函数">8.2.2 定义add函数</h3>
<p><code>add</code>函数接受两个<code>Sales_data</code>对象作为参数，其返回值为一个新的<code>Sales_data</code>，用于表示它们的和：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Sales_data sum = lhs;</span><br><span class="line">    sum.<span class="built_in">combine</span>(rhs);<span class="comment">//把rhs的数据加到sum中</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用新的对象<code>sum</code>操作，最后返回<code>sum</code>的副本。</p>
<h2 id="8-3-构造函数">8.3 构造函数</h2>
<p>每个类都分别定义了它的对象被初始化的方式，类会通过一个或几个特殊的成员来控制其对象的初始化过程。这些函数就叫构造函数。</p>
<ul>
<li>构造函数的任务是来初始化类对象的数据成员的，无论何时只要类的对象被创造，就会执行构造函数。</li>
<li>构造函数的名字与类的名字相同。</li>
<li>构造函数没有返回类型。</li>
<li>类可以包含多个构造函数，它们的关系和重载函数一样。</li>
<li>构造函数不能被声明为<code>const</code>，因为我们在创建类的一个<code>const</code>对象时，知道构造函数完成初始化过程，这个对象才能获得常量属性。</li>
</ul>
<h3 id="8-3-1-合成的默认构造函数">8.3.1 合成的默认构造函数</h3>
<p>我们的<code>Sales_data</code>类并没有定义任何构造函数，但我们使用<code>Sales_data</code>对象的程序依旧正确地编译和运行，是因为它们被进行了默认初始化。<br>
类通过一个特殊的的构造函数来控制默认初始化过程，这个函数也叫默认构造函数。<br>
当我们的类没有显式地定义构造函数时，那么编译器就会为我们隐式地定义一个默认构造函数。这个函数就叫合成的默认构造函数。<br>
它会按照如下规则进行初始化数据成员：</p>
<ul>
<li>如果在类中有初始值，用它来初始化成员。</li>
<li>否则，默认初始化该成员。</li>
</ul>
<p>例子中，<code>unit_sold</code>和<code>revenue</code>都提供了初始值，它们将在构造函数中被这个初始值初始化，而<code>bookNo</code>就被默认初始化为一个空字符串了。</p>
<h3 id="8-3-2-定义构造函数">8.3.2 定义构造函数</h3>
<p>为了灵活性考虑，我们决定自己定义构造函数而不是使用合成的默认构造函数。<br>
稍加思考，我们定义4个不同的构造函数：</p>
<ol>
<li>一个<code>istream &amp;</code>，从中读取一条信息</li>
<li>一个<code>const string &amp;</code>，表示图书编号，一个<code>unsigned</code>，表示售出图书数量，以及一个<code>double</code>表示图书售出价格</li>
<li>一个<code>const string &amp;</code>，表示图书编号；编译器将赋予其他函数默认值</li>
<li>一个空列表，即默认构造函数</li>
</ol>
<p>我们为类添加上我们新建的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s) : <span class="built_in">bookNo</span>(s) &#123; &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p) :</span><br><span class="line">                <span class="built_in">bookNo</span>(s), <span class="built_in">unit_sold</span>(n), <span class="built_in">revenue</span>(p * n)&#123; &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream &amp;);        </span><br><span class="line">    <span class="comment">//成员操作</span></span><br><span class="line">    <span class="function">std::string <span class="title">id</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo; &#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span> <span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//数据成员</span></span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> unit_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="8-3-2-1-default的含义">8.3.2.1 default的含义</h4>
<p>我们发现了默认构造函数（没有任何形参的构造函数）长这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
<p>我们定义这个构造函数的目的是为了想让默认构造函数和之前的合成的默认构造函数一样，但是又因为我们定义了其他的构造函数，编译器不再会为我们生成合成的默认构造函数，故，在C++中，我们需要有默认的行为，就可以在函数的形参列表后面写上<code>= default</code>来要求编译器自动生成默认构造函数。<br>
其中，<code>= default</code>既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。（内部就是inline函数，外部就不是）<br>
当然，有一点你得注意，默认构造函数之所以可以有效初始化，是因为我们为内置类型的数据成员提供了初始值，如果你的编译器不支持类内初始值，那么你就必须使用构造函数初始值列表（下文）的方式来初始化类的每个成员。</p>
<h4 id="8-3-2-2-构造函数初始值列表">8.3.2.2 构造函数初始值列表</h4>
<p>接下来我们介绍类中定义的另外两个构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s) : <span class="built_in">bookNo</span>(s) &#123; &#125;</span><br><span class="line">   <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p) :</span><br><span class="line">               <span class="built_in">bookNo</span>(s), <span class="built_in">unit_sold</span>(n), <span class="built_in">revenue</span>(p * n)&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>朋友们应该都发现了，这两个构造函数有些不一样的独特之处，它们多出来一个冒号<code>:</code>、要初始化的数据成员名称、以及后面像函数一样的花括号<code>()</code>。这些新出现的部分，称之为构造函数初始值列表。<br>
它负责为新创建的对象的一个或几个数据成员赋初始值，每个成员后面的花括号<code>()</code>里面的值，就是它被赋予的初始值。<br>
因为是构造函数有重载函数，故它也会根据你实参传入的情况进行选择调用。<br>
而关于这些构造函数的函数体是空的原因是，这些构造函数的唯一目的就是为数据成员赋初始值，一旦没有别的任务需要执行，函数体自然就空了。</p>
<h4 id="8-3-2-3-在类外定义构造函数">8.3.2.3 在类外定义构造函数</h4>
<p>与其他几个构造函数不同的是，以<code>istream</code>为参数的构造函数因为要执行一些实际操作，我们就把它放在类外进行定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::<span class="built_in">Sales_data</span>(std::istream &amp;is) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">read</span>(is, *<span class="keyword">this</span>);<span class="comment">//从istream输入一条信息，存入this指向的对象里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，构造函数没有返回值类型，我们直接从类名、作用域运算符、函数名…开始描述。<br>
而这个构造函数的构造函数初始值列表是空的，但因为函数体里有能进行为对象赋值的语句，我们也视为初始化了。且<code>read</code>函数的第二给参数是一个<code>Sales_data &amp;</code>，可以直接修改被传入的实参本身。（这样就完成了从istream里读取一条信息，并为this指向的对象赋值）</p>
<p>而没有出现在构造函数初始化列表中的成员将通过类内初始值（如果存在的话）进行初始化，或者默认初始化。</p>
<h3 id="8-3-3-拷贝-赋值和析构">8.3.3 拷贝、赋值和析构</h3>
<p>除了定义类的对象如何初始化之外，类还需要拷贝、赋值和销毁对象时发生的行为。<br>
当我们执行语句<code>Sales_data total;</code>时就创建了<code>Sales_data</code>类型对象<code>total</code>，并执行构造函数。<br>
而我们对象不再存在时就执行销毁的操作，比如局部的对象在创建它的块结束时被销毁。<br>
当我们初始化形参或者返回一个对象等时候，就执行了拷贝操作。<br>
当我们使用了赋值运算符时也是执行了赋值操作。</p>
<p>同样的，当我们不主动定义这些操作（笔者也会在之后的章节更新关于自定义上述操作的内容），则编译器会替我们合成它们。一般来说，编译器生成的版本将会对对象的每个成员都执行拷贝、赋值和销毁的操作。<br>
比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total = trans;</span><br></pre></td></tr></table></figure>
<p>就等于</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total.bookNo = trans.bookNo;</span><br><span class="line">   total.unit_sold = trans.unit_sold;</span><br><span class="line">   total.revenue = trans.revenue;</span><br></pre></td></tr></table></figure>
<p>不过，尽管编译器能代替我们合成拷贝、赋值和销毁的操作，但对于某些类来说合成的版本无法正常工作。特别是，当类需要分配类对象之外的资源的时候，合成的版本往往会失效。笔者将会在后续介绍C++程序内存分配和管理动态内存的章节中介绍管理内存的类，它通常就不能依赖上述操作的合成版本。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://rich-blog.cn">瑞奇</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rich-blog.cn/2023/02/01/%E7%B1%BB-%E4%B8%8A-%E2%80%94%E2%80%94%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E4%BB%8EC%E5%88%B0C-%E7%AC%AC%E5%85%AD%E6%9C%9F/">https://rich-blog.cn/2023/02/01/%E7%B1%BB-%E4%B8%8A-%E2%80%94%E2%80%94%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E4%BB%8EC%E5%88%B0C-%E7%AC%AC%E5%85%AD%E6%9C%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rich-blog.cn" target="_blank">瑞奇的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c/">c++</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/03/%E7%B1%BB-%E4%B8%AD-%E2%80%94%E2%80%94%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E4%BB%8EC%E5%88%B0C-%E7%AC%AC%E4%B8%83%E6%9C%9F/" title="类(中)——跟我一起从C到C++(第七期)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/4.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">类(中)——跟我一起从C到C++(第七期)</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/31/%E5%87%BD%E6%95%B0-%E4%B8%8B-%E2%80%94%E2%80%94%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E4%BB%8EC%E5%88%B0C-%E7%AC%AC%E4%BA%94%E6%9C%9F/" title="函数(下)——跟我一起从C到C++(第五期)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">函数(下)——跟我一起从C到C++(第五期)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/07/IO%E5%BA%93%E2%80%94%E2%80%94%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E4%BB%8EC%E5%88%B0C-%E7%AC%AC%E4%B9%9D%E6%9C%9F/" title="IO库——跟我一起从C到C++(第九期)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-07</div><div class="title">IO库——跟我一起从C到C++(第九期)</div></div></a></div><div><a href="/2023/02/09/C-C-%E5%A4%8D%E6%9D%82%E8%AE%A1%E7%AE%97%E5%99%A8%E2%80%94%E2%80%94%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%EF%BC%88%E4%B8%AD%E7%BC%80%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89/" title="【C&#x2F;C++】 复杂计算器——四则运算表达式求值（中缀转后缀表达式）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-09</div><div class="title">【C&#x2F;C++】 复杂计算器——四则运算表达式求值（中缀转后缀表达式）</div></div></a></div><div><a href="/2023/02/11/KMP%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%92%8C%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/" title="【KMP算法】算法分析和代码解析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-11</div><div class="title">【KMP算法】算法分析和代码解析</div></div></a></div><div><a href="/2023/02/03/Linux-C-C-%E5%AE%9E%E7%8E%B0ls-R%E7%9A%84%E5%91%BD%E4%BB%A4/" title="【Linux C&#x2F;C++】 实现ls -R的命令"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-03</div><div class="title">【Linux C&#x2F;C++】 实现ls -R的命令</div></div></a></div><div><a href="/2023/01/31/%E5%87%BD%E6%95%B0-%E4%B8%8B-%E2%80%94%E2%80%94%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E4%BB%8EC%E5%88%B0C-%E7%AC%AC%E4%BA%94%E6%9C%9F/" title="函数(下)——跟我一起从C到C++(第五期)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-31</div><div class="title">函数(下)——跟我一起从C到C++(第五期)</div></div></a></div><div><a href="/2023/01/30/%E5%87%BD%E6%95%B0-%E4%B8%8A-%E2%80%94%E2%80%94%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E4%BB%8EC%E5%88%B0C-%E7%AC%AC%E5%9B%9B%E6%9C%9F/" title="函数(上)——跟我一起从C到C++(第四期)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-30</div><div class="title">函数(上)——跟我一起从C到C++(第四期)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/pearl.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">瑞奇</div><div class="author-info__description">一个心怀浪漫的少年</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://blog.csdn.net/DreamTrue520?spm=1011.2124.3001.5343"><i></i><span>🛴前往小家...</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/info/wechat" target="_blank" title="WeChat"><i class="fab fa-weixin"></i></a><a class="social-icon" href="/info/qq" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="https://github.com/mico845" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1120845871@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95"><span class="toc-text">文章目录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E7%B1%BB"><span class="toc-text">8 类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E5%AE%9A%E4%B9%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">8.1 定义抽象数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-1-%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9F%E7%B1%BB%EF%BC%9F"><span class="toc-text">8.1.1 结构体？类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-2-%E5%AE%9A%E4%B9%89%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">8.1.2 定义成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-1-this%E6%8C%87%E9%92%88"><span class="toc-text">8.1.2.1 this指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-2-const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">8.1.2.2 const成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-3-%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">8.1.2.3 类作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-4-%E5%9C%A8%E7%B1%BB%E5%A4%96%E5%AE%9A%E4%B9%89%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">8.1.2.4 在类外定义成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-2-4-1-%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">8.1.2.4.1 作用域运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-2-4-2-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E8%BF%94%E5%9B%9Ethis%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">8.1.2.4.2 定义一个返回this对象的函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">8.2 定义类相关的非成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-%E5%AE%9A%E4%B9%89read%E5%92%8Cprint%E5%87%BD%E6%95%B0"><span class="toc-text">8.2.1 定义read和print函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-%E5%AE%9A%E4%B9%89add%E5%87%BD%E6%95%B0"><span class="toc-text">8.2.2 定义add函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">8.3 构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1-%E5%90%88%E6%88%90%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">8.3.1 合成的默认构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-2-%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">8.3.2 定义构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2-1-default%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-text">8.3.2.1 default的含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2-2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%80%BC%E5%88%97%E8%A1%A8"><span class="toc-text">8.3.2.2 构造函数初始值列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2-3-%E5%9C%A8%E7%B1%BB%E5%A4%96%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">8.3.2.3 在类外定义构造函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-3-%E6%8B%B7%E8%B4%9D-%E8%B5%8B%E5%80%BC%E5%92%8C%E6%9E%90%E6%9E%84"><span class="toc-text">8.3.3 拷贝、赋值和析构</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 瑞奇</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>