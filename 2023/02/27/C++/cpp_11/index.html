<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>顺序容器(下)——跟我一起从C到C++(第十一期) | 瑞奇的博客</title><meta name="author" content="瑞奇"><meta name="copyright" content="瑞奇"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="10 顺序容器 承接顺序容器(上)——跟我一起从C到C++(第十期) 10.4 管理迭代器 10.4.1 容器操作可能使迭代器失效 向容器中添加元素或者从容器中删除元素可能使容器元素的指针、引用或者迭代器失效。一个失效的指针、引用或者迭代器不再能表示任何元素。使用就会造成严重的程序设计错误，可能引起与使用未初始化指针一样的问题。 向容器添加元素后：  如果容器是vector或string，且存储空">
<meta property="og:type" content="article">
<meta property="og:title" content="顺序容器(下)——跟我一起从C到C++(第十一期)">
<meta property="og:url" content="https://rich-blog.cn/2023/02/27/C++/cpp_11/index.html">
<meta property="og:site_name" content="瑞奇的博客">
<meta property="og:description" content="10 顺序容器 承接顺序容器(上)——跟我一起从C到C++(第十期) 10.4 管理迭代器 10.4.1 容器操作可能使迭代器失效 向容器中添加元素或者从容器中删除元素可能使容器元素的指针、引用或者迭代器失效。一个失效的指针、引用或者迭代器不再能表示任何元素。使用就会造成严重的程序设计错误，可能引起与使用未初始化指针一样的问题。 向容器添加元素后：  如果容器是vector或string，且存储空">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://rich-blog.cn/img/cover/cover_8.png">
<meta property="article:published_time" content="2023-02-27T08:33:00.000Z">
<meta property="article:modified_time" content="2023-02-27T08:33:45.558Z">
<meta property="article:author" content="瑞奇">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rich-blog.cn/img/cover/cover_8.png"><link rel="shortcut icon" href="/img/panda.png"><link rel="canonical" href="https://rich-blog.cn/2023/02/27/C++/cpp_11/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '顺序容器(下)——跟我一起从C到C++(第十一期)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-27 16:33:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-tag-plugins@latest/lib/tag_plugins.min.css" media="defer" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/hexo-tag-plugins@latest/lib/carousel-touch.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-tag-plugins@latest/lib/mindmap.min.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="瑞奇的博客" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/pearl.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/life/"><i class="fa-fw fas fa-globe"></i><span> 生活</span></a></li><li><a class="site-page child" href="/table/"><i class="fa-fw fas fa-table-list"></i><span> 课程表</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover/cover_8.png')"><nav id="nav"><span id="blog-info"><a href="/" title="瑞奇的博客"><span class="site-name">瑞奇的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/life/"><i class="fa-fw fas fa-globe"></i><span> 生活</span></a></li><li><a class="site-page child" href="/table/"><i class="fa-fw fas fa-table-list"></i><span> 课程表</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">顺序容器(下)——跟我一起从C到C++(第十一期)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-27T08:33:00.000Z" title="发表于 2023-02-27 16:33:00">2023-02-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-27T08:33:45.558Z" title="更新于 2023-02-27 16:33:45">2023-02-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E4%BB%8EC%E5%88%B0C/">跟我一起从C到C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="顺序容器(下)——跟我一起从C到C++(第十一期)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="10-顺序容器">10 顺序容器</h1>
<p>承接<a href="/2023/02/25/C++/cpp_10/">顺序容器(上)——跟我一起从C到C++(第十期)</a></p>
<h2 id="10-4-管理迭代器">10.4 管理迭代器</h2>
<h3 id="10-4-1-容器操作可能使迭代器失效">10.4.1 容器操作可能使迭代器失效</h3>
<p>向容器中添加元素或者从容器中删除元素可能使容器元素的指针、引用或者迭代器失效。一个失效的指针、引用或者迭代器不再能表示任何元素。使用就会造成严重的程序设计错误，可能引起与使用未初始化指针一样的问题。<br>
向容器添加元素后：</p>
<ul>
<li>如果容器是<code>vector</code>或<code>string</code>，且存储空间被重新分配，则指向容器的迭代器、指针、引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍然有效，但指向插入位置之后的元素的迭代器、指针和引用将会失效。</li>
<li>对于<code>deque</code>，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。</li>
<li>对于<code>list</code>和<code>forward_list</code>，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针、引用仍然有效。</li>
</ul>
<p>当删除一个元素后：</p>
<ul>
<li>当我们删除元素时，尾后迭代器总会失效。</li>
<li>对于<code>list</code>和<code>forward_list</code>，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针、引用仍然有效。</li>
<li>对于<code>deque</code>，如果在首尾之外的任何位置删除元素，那么指向被指向被删除元素外的其他元素的迭代器、指针和引用都会失效。如果删除的是<code>deque</code>的尾元素，则尾后迭代器也会失效，但其他的迭代器、指针和引用不受影响；如果是删除首元素，这些也不会受影响。</li>
<li>对于<code>vector</code>或<code>string</code>，指向被删除元素之外的元素的迭代器、引用和指针仍有效。</li>
</ul>
<h3 id="10-4-2-改变容器的循环">10.4.2 改变容器的循环</h3>
<p>添加或者删除元素的时候，循环程序必须考虑迭代器、引用、指针可能失效的问题。程序必须保证每个循环步骤中都更新迭代器、引用或者指针。如果循环中调用的是<code>insert</code>或<code>erase</code>，那么更新迭代器会很容易。这些操作都会返回迭代器，我们可以用来更新：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  </span><br><span class="line"><span class="keyword">auto</span> iter = v.<span class="built_in">begin</span>();  </span><br><span class="line"><span class="keyword">while</span> (iter != v.<span class="built_in">end</span>())  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> (*iter % <span class="number">2</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        iter = v.<span class="built_in">insert</span>(iter, *iter);  </span><br><span class="line">        iter += <span class="number">2</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        iter = v.<span class="built_in">erase</span>(iter);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里还要讲一个习惯——不要保存<code>end()</code>返回的迭代器。<br>
通常C++标准库中的<code>end()</code>处理都很快速，我们不用试图“优化”这个循环，反则当我们在循环中进行一些操作使得保存<code>end()</code>中的迭代器失效了，那么这个迭代器讲不再指向容器中的任何元素或是尾后元素了。<br>
所以你会发现，程序员们一般：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> iter = v.<span class="built_in">begin</span>();  </span><br><span class="line"><span class="keyword">while</span> (iter != v.<span class="built_in">end</span>())  </span><br></pre></td></tr></table></figure>
<p>而不是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> iter = v.<span class="built_in">begin</span>();  </span><br><span class="line"><span class="keyword">auto</span> last = v.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">while</span> (iter != last)  </span><br></pre></td></tr></table></figure>
<h2 id="10-5-vector对象是如何增长的">10.5 vector对象是如何增长的</h2>
<p>参考：<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/zx714311728/article/details/69944546">vector空间的动态增长</a></p>
<p><code>vector</code>和<code>string</code>的情况类似，这里就用<code>vector</code>进行描述。<br>
当添加元素时，如果<code>vector</code>空间大小不足，则会以原大小的两倍另外配置一块较大的新空间，然后将原空间内容拷贝过来，在新空间的内容末尾添加元素，并释放原空间。<code>vector</code>的空间动态增加大小，并不是在原空间之后的相邻地址增加新空间，因为<code>vector</code>的空间是线性连续分配的，不能保证原空间之后有可供配置的空间。因此，对<code>vector</code>的任何操作，一旦引起空间的重新配置，指向原<code>vector</code>的所有迭代器就会失效。</p>
<h3 id="10-5-1-管理容量">10.5.1 管理容量</h3>
<p><code>vector</code>提供了一些成员函数，允许我们与它的实现中内存分配部分互动。<code>capacity</code>操作告诉我们容器不扩张内存空间的情况下可以容纳多少个元素。<code>reserve</code>操作告诉我们通知容器它应该准备多少个元素。</p>
<p><code>size()</code>函数返回的是已用空间大小，<code> capacity()</code>返回的是总空间大小， <code>capacity()-size()</code>则是剩余的可用空间大小。当<code>size()</code>和<code>capacity()</code>相等，说明<code>vector</code>目前的空间已被用完，如果再添加新元素，则会引起<code>vector</code>空间的动态增长。<br>
由于动态增长会引起重新分配内存空间、拷贝原空间、释放原空间，这些过程会降低程序效率。因此，可以使用 <code>reserve(n)</code>预先分配一块较大的指定大小的内存空间，这样当指定大小的内存空间未使用完时，是不会重新分配内存空间的，这样便提升了效率。只有当<code>n&gt;capacity()</code>时，调用<code>reserve(n)</code>才会改变<code>vector</code>容量。<br>
<code>resize()</code>成员函数只改变元素的数目，不改变<code>vector</code>的容量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;  </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; v.<span class="built_in">size</span>()  </span><br><span class="line">     &lt;&lt; <span class="string">&quot; capacity: &quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出：size: <span class="number">0</span> capacity: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>当我们加入元素，<code>vector</code>的<code>size</code>和<code>capacity</code>都会增加：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);  </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; v.<span class="built_in">size</span>()  </span><br><span class="line">     &lt;&lt; <span class="string">&quot; capacity: &quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出：size: <span class="number">1</span> capacity: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><code>capacity</code>的增长至少与<code>size</code>一样大，具体分配多少额外空间则视标准库具体实现而定：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::size_type i = <span class="number">0</span>; i != <span class="number">24</span>; ++i)  </span><br><span class="line">    v.<span class="built_in">push_back</span>(i);  </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; v.<span class="built_in">size</span>()  </span><br><span class="line">     &lt;&lt; <span class="string">&quot; capacity: &quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出：size: <span class="number">24</span> capacity: <span class="number">32</span></span><br></pre></td></tr></table></figure>
<p>我们也可以用<code>reserve</code>设置预分配空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;  </span><br><span class="line">v.<span class="built_in">reserve</span>(<span class="number">50</span>);  </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; v.<span class="built_in">size</span>()  </span><br><span class="line">     &lt;&lt; <span class="string">&quot; capacity: &quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出：size: <span class="number">0</span> capacity: <span class="number">50</span></span><br></pre></td></tr></table></figure>
<p>当这新分配的空间<code>50</code>也被用完了，就再拿给程序分配，分配的具体值又得依赖于标准库的具体实现了。</p>
<p>这里还有一种操作<code>shrink_to_fit</code>来要求<code>deque</code>、<code>vector</code>或<code>string</code>将<code>capacity()</code>减少到<code>size()</code>相同大小。这意味着要求容器归还超出当前大小的多余内存。</p>
<blockquote>
<p>每个vector实现都可以选择自己的内存分配策略。但是必须遵守一条原则：只有迫不得己的时候才可以分配新的内存空间。</p>
</blockquote>
<h2 id="10-6-额外的string操作">10.6 额外的string操作</h2>
<p>除了顺序容器共同的操作之外，<code>string</code>类型还提供了一些额外的操作。这些操作中大部分要么提供<code>string</code>类和C风格字符数组之间的相互转换，要么是增加了允许我们用下标替代迭代器版本。</p>
<h3 id="10-6-1-构造string的其他方法">10.6.1 构造string的其他方法</h3>
<p><code>n</code>、<code>len2</code>、<code>pos2</code>都是无符号值。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>string s(cp,n)</code></td>
<td><code>s</code>是<code>cp</code>指向的数组中前<code>n</code>个字符的拷贝</td>
</tr>
<tr>
<td><code>string s(s2,pos2)</code></td>
<td><code>s</code>是<code>string s2</code>从下标<code>pos2</code>开始的字符的拷贝。如果<code>pos2&gt;s2.size()</code>，则构造函数的行为未定义</td>
</tr>
<tr>
<td><code>string s(s2,pos2,len2)</code></td>
<td><code>s</code>是<code>string s2</code>从下标<code>pos2</code>开始<code>len2</code>个字符的拷贝。如果<code>pos2&gt;s2.size()</code>，则构造函数的行为未定义</td>
</tr>
</tbody>
</table>
<p>这些构造函数参数<code>cp</code>接受一个<code>string</code>或者一个<code>const char *</code>参数。</p>
<h3 id="10-6-2-substr操作">10.6.2 substr操作</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>substr(pos,n)</code></td>
<td>返回一个<code>string</code>。包含<code>s</code>中从<code>pos</code>开始的<code>n</code>个字符的拷贝。<code>pos</code>默认值为<code>0</code>。<code>n</code>的默认值为<code>s.size()-pos</code>，即拷贝从<code>pos</code>开始的全部字符</td>
</tr>
</tbody>
</table>
<p><code>substr</code>操作返回一个<code>string</code>，它的原始string的一部分或者全部的拷贝。可以传递给<code>substr</code>一个可选的开始位置和计数值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;  </span><br><span class="line">string s2 = s.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">5</span>);<span class="comment">//hello  </span></span><br><span class="line">string s3 = s.<span class="built_in">substr</span>(<span class="number">6</span>);<span class="comment">//world  </span></span><br><span class="line">string s4 = s.<span class="built_in">substr</span>(<span class="number">6</span>, <span class="number">11</span>);<span class="comment">//world  </span></span><br><span class="line">string s5 = s.<span class="built_in">substr</span>(<span class="number">12</span>);<span class="comment">//抛出一个out_of_range异常</span></span><br></pre></td></tr></table></figure>
<h3 id="10-6-3-改变string的其他方法">10.6.3 改变string的其他方法</h3>
<p><code>string</code>类型支持顺序容器的赋值运算符、<code>assign</code>、<code>insert</code>和<code>erase</code>操作。除此之外，它还定义了额外版本的<code>insert</code>和<code>erase</code>。<br>
yes，除了接受迭代器版本的<code>insert</code>和<code>erase</code>，<code>string</code>还提供接受下标版本的版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">insert</span>(s.<span class="built_in">size</span>(), <span class="number">5</span>, <span class="string">&#x27;!&#x27;</span>);<span class="comment">//在s末尾插入5个感叹号  </span></span><br><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">size</span>() - <span class="number">5</span>, <span class="number">5</span>);<span class="comment">//在s删除最后5个字符</span></span><br></pre></td></tr></table></figure>
<p>因为要与C风格字符串打交道，<code>string</code>类型提供了接受C风格字符串的<code>insert</code>和<code>assign</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *cp = <span class="string">&quot;Stately, plump buck!&quot;</span>;  </span><br><span class="line">s.<span class="built_in">assign</span>(cp, <span class="number">7</span>);<span class="comment">//Stately  </span></span><br><span class="line">s.<span class="built_in">insert</span>(s.<span class="built_in">size</span>(), cp+<span class="number">7</span>);<span class="comment">//Stately, plump buck!</span></span><br></pre></td></tr></table></figure>
<p>而且，string类型还定义了两个额外的<code>append</code>和<code>replace</code></p>
<p><code>append</code>操作是在<code>string</code>末尾进行插入的一种简写形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">insert</span>(s.<span class="built_in">size</span>(), <span class="string">&quot;world&quot;</span>); </span><br></pre></td></tr></table></figure>
<p>可以变成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">append</span>(<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>而<code>replace</code>操作是在<code>erase</code>和<code>insert</code>的一种简写形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hello 5 world&quot;</span>)</span></span>;  </span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">6</span>, <span class="number">1</span>);  </span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">6</span>, <span class="string">&quot;4&quot;</span>);<span class="comment">//hello 4 world</span></span><br></pre></td></tr></table></figure>
<p>可以变成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">replace</span>(<span class="number">6</span>, <span class="number">1</span>, <span class="string">&quot;4&quot;</span>);<span class="comment">//hello 4 world</span></span><br></pre></td></tr></table></figure>
<p>而且，调用<code>replace</code>操作时，与插入文本与删除文本不一样长时，也可以生效：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">replace</span>(<span class="number">6</span>, <span class="number">1</span>, <span class="string">&quot;4th&quot;</span>);<span class="comment">//hello 4th world</span></span><br></pre></td></tr></table></figure>
<h3 id="10-6-4-搜索操作">10.6.4 搜索操作</h3>
<p><code>string</code>类提供了6种不同的搜索函数，<br>
每个搜索操作都会返回一个<code>string::size_type</code>值，表示匹配发生位置的下标。<br>
如果搜索失败，则会返回一个名为<code>string::npos</code>的<code>static</code>成员。</p>
<ul>
<li><strong>find</strong><br>
<code>find</code>函数完成最简单的搜索，它查找参数定义的字符串，若找到，则返回第一个匹配位置的下标，否则就是<code>npos</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;united state&quot;</span>)</span></span>;  </span><br><span class="line"><span class="keyword">auto</span> pos =  s.<span class="built_in">find</span>(<span class="string">&quot;united&quot;</span>);<span class="comment">// pos == 0</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>find_first_not_of</strong><br>
<code>find_first_not_of</code>搜索第一个不在参数中的字符：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">numbers</span><span class="params">(<span class="string">&quot;0123456789&quot;</span>)</span></span>;  </span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;0377114p3&quot;</span>)</span></span>;  </span><br><span class="line"><span class="keyword">auto</span> pos = s.<span class="built_in">find_first_not_of</span>(numbers);<span class="comment">//7</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>指定在哪里开始搜索</strong><br>
<code>find_first_not_of</code>会返回参数中任何一个字符第一次出现的位置。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">numbers</span><span class="params">(<span class="string">&quot;0123456789&quot;</span>)</span></span>;  </span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;r2d2&quot;</span>)</span></span>;  </span><br><span class="line">string::size_type pos = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">while</span> ((pos = s.<span class="built_in">find_first_not_of</span>(numbers, pos)) != string::npos)  </span><br><span class="line">&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;found number at index: &quot;</span> &lt;&lt; pos  </span><br><span class="line">        &lt;&lt; <span class="string">&quot; element is &quot;</span> &lt;&lt; s[pos] &lt;&lt; endl;  </span><br><span class="line">    ++pos;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">found number at index: <span class="number">0</span> element is r</span><br><span class="line">found number at index: <span class="number">2</span> element is d</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>逆向搜索</strong><br>
<code>find</code>由左往右搜索，而<code>rfind</code>由右往左搜索：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;r2d2&quot;);  </span><br><span class="line">auto pos = s.find(&quot;2&quot;);//1  </span><br><span class="line">auto rpos = s.rfind(&quot;2&quot;);//3</span><br></pre></td></tr></table></figure>
<p>类似的，<code>find_last</code>的函数的功能与<code>find_first</code>的函数相似，只是它们返回最后一个而不是第一个匹配。</p>
<p><strong>总结一下就是：</strong><br>
搜索操作返回指定的字符出现的下标，否则就是<code>string::npos</code></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s.find(args)</code></td>
<td>查找<code>args</code>第一次出现的位置</td>
</tr>
<tr>
<td><code>s.rfind(args)</code></td>
<td>查找<code>args</code>最后一次出现的位置</td>
</tr>
<tr>
<td><code>s.find_first_of(args)</code></td>
<td>查找<code>args</code>中任何一个字符第一次出现的位置</td>
</tr>
<tr>
<td><code>s.find_last_of(args)</code></td>
<td>查找<code>args</code>中任何一个字符最后一次出现的位置</td>
</tr>
<tr>
<td><code>s.find_first_not_of(args)</code></td>
<td>查找第一个不在<code>args</code>中的字符的位置</td>
</tr>
<tr>
<td><code>s.find_last_not_of(args)</code></td>
<td>查找最后一个不在<code>args</code>中的字符的位置</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><code>args</code>形式</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c,pos</code></td>
<td>从<code>s</code>的<code>pos</code>位置找字符<code>c</code>，<code>pos</code>默认为0</td>
</tr>
<tr>
<td><code>s2,pos</code></td>
<td>从<code>s</code>的<code>pos</code>位置字符串<code>s2</code>，<code>pos</code>默认为0</td>
</tr>
<tr>
<td><code>cp,pos</code></td>
<td>从<code>s</code>的<code>pos</code>位置C风格字符串指针<code>cp</code>，<code>pos</code>默认为0</td>
</tr>
<tr>
<td><code>cp,pos,n</code></td>
<td>从<code>s</code>的<code>pos</code>位置C风格字符串指针<code>cp</code>的前<code>n</code>个字符，<code>pos</code>和<code>n</code>无默认值</td>
</tr>
</tbody>
</table>
<h3 id="10-6-5-compare函数">10.6.5 compare函数</h3>
<p><code>string</code>类型的<code>compare</code>函数很类似C标准库里的<code>strcmp</code>函数。<br>
根据<code>s</code>是等于、大于或者小于参数指定的字符串，<code>s.compare</code>返回<code>0</code>、正数或者负数。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s.compare(s2)</code></td>
<td>比较<code>s</code>和<code>s2</code></td>
</tr>
<tr>
<td><code>s.compare(pos1,n1,s2)</code></td>
<td>将<code>s</code>中从<code>pos1</code>开始的<code>n1</code>个字符与<code>s2</code>比较</td>
</tr>
<tr>
<td><code>s.compare(pos1,n1,s2,pos2,n2)</code></td>
<td>将<code>s</code>中从<code>pos1</code>开始的<code>n1</code>个字符与<code>s2</code>从<code>pos2</code>开始的<code>n2</code>个字符比较</td>
</tr>
<tr>
<td><code>s.compare(cp)</code></td>
<td>比较<code>s</code>和C风格字符串<code>cp</code></td>
</tr>
<tr>
<td><code>s.compare(pos1,n1,cp)</code></td>
<td>将<code>s</code>中从<code>pos1</code>开始的<code>n1</code>个字符与C风格字符串<code>cp</code>比较</td>
</tr>
<tr>
<td><code>s.compare(pos1,n1,cp,pos2,n2)</code></td>
<td>将<code>s</code>中从<code>pos1</code>开始的<code>n1</code>个字符与C风格字符串<code>cp</code>从<code>pos2</code>开始的<code>n2</code>个字符比较</td>
</tr>
</tbody>
</table>
<h3 id="10-6-6-数值转换">10.6.6 数值转换</h3>
<p>字符串常常包含数值，我们可以通过一些函数进行转换：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>to_string(val)</code></td>
<td>一组重载函数。返回数值<code>val</code>的<code>string</code>表示(小整形会被提升)</td>
</tr>
<tr>
<td><code>stoi(s,p,b)</code><br><code>stol(s,p,b)</code><br><code>stoul(s,p,b)</code><br><code>stoll(s,p,b)</code><br><code>stoull(s,p,b)</code></td>
<td>返回<code>s</code>的起始字串的数值，返回类型分别是<code>int</code>、<code>long</code>、<code>unsigned long</code>、<code>long long</code>。<code>b</code>表示转换所用的基数，默认值为<code>10</code>。<code>p</code>是<code>size_t</code>指针，用来保存第一个非数值的字符的下标，<code>p</code>默认为<code>0</code>。</td>
</tr>
<tr>
<td><code>stof(s,p)</code><br><code>stod(s,p)</code><br><code>stould(s,p)</code></td>
<td>返回<code>s</code>的起始字串的数值，返回类型分别是<code>float</code>、<code>double</code>、<code>long double</code>。<code>p</code>是<code>size_t</code>指针，用来保存第一个非数值的字符的下标，<code>p</code>默认为<code>0</code>。</td>
</tr>
</tbody>
</table>
<ul>
<li><code>sto</code>系列的函数必须把数值放在首位。</li>
</ul>
<p>比如，<br>
字符串和整型数值互转：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">string s = <span class="built_in">to_string</span>(i);<span class="comment">//int -&gt; string  </span></span><br><span class="line"><span class="type">double</span> d = <span class="built_in">stod</span>(s);<span class="comment">//string -&gt; double</span></span><br></pre></td></tr></table></figure>
<p>字符串提取浮点数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;pi = 3.14&quot;</span>)</span></span>;  </span><br><span class="line"><span class="type">double</span> d = <span class="built_in">stod</span>(s.<span class="built_in">substr</span>(s.<span class="built_in">find_first_of</span>(<span class="string">&quot;+-.1234567890&quot;</span>)));</span><br></pre></td></tr></table></figure>
<p>重点说一下这个例子，它先利用<code>find_first_of</code>找到第一次含<code>+-.1234567890</code>的字符串然后返回所在下标，并使用<code>substr</code>将前面不能转换的地方分离，然后进行<code>stod</code>转换。</p>
<h2 id="10-7-容器适配器">10.7 容器适配器</h2>
<p>除了顺序容器外，标准库还定义了三个顺序容器适配器：<code>stack</code>、<code>queue</code>和<code>priority_queue</code>。<br>
适配器是标准库中的一个通用概念。容器、迭代器和函数都有适配器。<br>
一个适配器就是一种机制，使其行为看起来像一种不同的类型。例如，<code>stack</code>适配器接受一个顺序容器（除<code>array</code>或<code>forward_list</code>外）并使其操作像一个<code>stack</code>一样。<br>
所有的容器适配器都有如下操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>size_type</code></td>
<td>一种类型，足以保存当前类型的最大对象的大小</td>
</tr>
<tr>
<td><code>value_type</code></td>
<td>元素类型</td>
</tr>
<tr>
<td><code>container_type</code></td>
<td>实现适配器的底层容器的类型</td>
</tr>
<tr>
<td><code>A a;</code></td>
<td>创建一个名为<code>a</code>的空适配器</td>
</tr>
<tr>
<td><code>A a(c);</code></td>
<td>创建一个名为<code>a</code>的适配器，带有容器<code>c</code>的拷贝</td>
</tr>
<tr>
<td><code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code></td>
<td>关系运算符</td>
</tr>
<tr>
<td><code>a.empty()</code></td>
<td>若包含<code>a</code>的任意元素，则返回<code>false</code>；否则返回<code>true</code></td>
</tr>
<tr>
<td><code>a.size()</code></td>
<td>返回<code>a</code>包含的元素数目</td>
</tr>
<tr>
<td><code>a.swap(b)</code><br><code>swap(a,b)</code></td>
<td>交换<code>a</code>和<code>b</code>的内容，<code>a</code>和<code>b</code>必须有相同类型，包括底层容器类型也必须相同</td>
</tr>
</tbody>
</table>
<h3 id="10-7-1-定义一个适配器">10.7.1 定义一个适配器</h3>
<p>我们可以用一个容器来初始化一个新的适配器，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt; deq;  </span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk&#123;deq&#125;;</span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>stack</code>和<code>queue</code>是基于<code>deque</code>实现的，<code>priority_queue</code>是在<code>vector</code>之上实现的。我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器模型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;string, vector&lt;string&gt;&gt; str_stk;  </span><br><span class="line"><span class="comment">//用vector&lt;string&gt;构造的类型为string的适配器str_stk  </span></span><br><span class="line">vector&lt;string&gt; svec;  </span><br><span class="line">stack&lt;string, vector&lt;string&gt;&gt; <span class="built_in">str_stk2</span>(svec);</span><br></pre></td></tr></table></figure>
<p>对于一个给定的适配器，可以使用哪些容器是受到限制的，所有适配器都要求容器具有添加和删除元素的功能。<br>
因此，适配器不能构造在<code>array</code>之上。<br>
类似的，我们也不能用<code>forward_list</code>来构造适配器，因为所有适配器都要有添加、删除以及访问尾元素的能力。</p>
<ul>
<li>stack只要求<code>push_back</code>、<code>pop_back</code>操作，也就是除了<code>array</code>和<code>forward_list</code>都可以用来构造<code>stack</code>。</li>
<li><code>queue</code>要求<code>back</code>、<code>push_back</code>、<code>front</code>和<code>push_front</code>，因此它可以在list或deque之上构造，但不能建立在<code>vector</code>。</li>
<li><code>priority_queue</code>要求<code>push_back</code>、<code>front</code>和<code>pop_front</code>，而且还要求有随机访问能力，因此它可以在<code>vector</code>或deque之上构造，但不能建立在<code>list</code>。</li>
</ul>
<h3 id="10-7-2-栈适配器">10.7.2 栈适配器</h3>
<p><code>stack</code>类型定义在头文件<code>&lt;stack&gt;</code><br>
<code>stack</code>类型基于<code>deque</code>实现，但也可以用<code>vector</code>或者<code>list</code>构造。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s.pop()</code></td>
<td>删除栈顶元素，但不能返回该元素值</td>
</tr>
<tr>
<td><code>s.push(item)</code></td>
<td>压入栈</td>
</tr>
<tr>
<td><code>s.emplace(args)</code></td>
<td>压入栈</td>
</tr>
<tr>
<td><code>s.top()</code></td>
<td>返回栈顶元素，但不弹出栈</td>
</tr>
</tbody>
</table>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; s;  </span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> ix = <span class="number">0</span>; ix != <span class="number">10</span>; ++ix)  </span><br><span class="line">    s.<span class="built_in">push</span>(ix);  </span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>())  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> val = s.<span class="built_in">top</span>();  </span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;  </span><br><span class="line">    s.<span class="built_in">pop</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line"><span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>总所周知，栈<code>stack</code>是先进后出的。</p>
<p>而且<code>s</code>不能使用顶层容器<code>deque</code>的<code>push_back</code>，而是自己的<code>push</code>。</p>
<h3 id="10-7-3-队列适配器">10.7.3 队列适配器</h3>
<p><code>queue</code>和<code>priority_queue</code>适配器定义在头文件<code>&lt;queue&gt;</code>。<br>
其中，<code>queue</code>默认基于<code>deque</code>实现，而<code>priority_queue</code>默认基于<code>vector</code>实现。<br>
当然，<code>queue</code>也可以用<code>list</code>或<code>vector</code>实现，而<code>priority_queue</code>也可以用<code>deque</code>实现。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>q.pop()</code></td>
<td>删除队列首元素，但不能返回该元素值</td>
</tr>
<tr>
<td><code>q.push(item)</code></td>
<td>在队列末尾插入一个元素</td>
</tr>
<tr>
<td><code>q.emplace(args)</code></td>
<td>在队列末尾插入一个元素</td>
</tr>
<tr>
<td><code>q.front()</code></td>
<td>返回首元素，但不删除该元素</td>
</tr>
<tr>
<td><code>q.back()</code></td>
<td>返回尾元素，但不删除该元素（只适用于<code>queue</code>）</td>
</tr>
<tr>
<td><code>q.top()</code></td>
<td>返回最高优先级元素，但不删除该元素（只适用于<code>priority_queue</code>）</td>
</tr>
</tbody>
</table>
<p>总所周知，队列<code>queue</code>是先进先出的（FIFO，进入的是队尾，出去的是队首，就好比排队）<br>
不过，这里多了一个<code>priority_queue</code>，允许我们为队列中的元素建立优先级。新加入的元素会排在所有优先级比它低的已有元素之前。就比如饭店按照客人预定的时间而不是到来的时间的早晚为他们安排座位。<br>
定义：<code>priority_queue&lt;Type, Container, Functional&gt;</code><br>
<code>Type</code> 就是数据类型，<code>Container</code> 就是容器类型（<code>Container</code>必须是用数组实现的容器，比如<code>vector</code>,<code>deque</code>等等，但不能用 <code>list</code>。<code>STL</code>里面默认用的是<code>vector</code>），<code>Functional </code>就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆。<br>
一般就是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序队列</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//降序队列</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）</span></span><br></pre></td></tr></table></figure>
<p>更多的用法，以后会在专文总提到，这里就让我们先有个印象就行。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://rich-blog.cn">瑞奇</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rich-blog.cn/2023/02/27/C++/cpp_11/">https://rich-blog.cn/2023/02/27/C++/cpp_11/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rich-blog.cn" target="_blank">瑞奇的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c/">c++</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/cover_8.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/27/Subject/Fundamentals%20of%20Circuit%20Analysis%20and%20Experiment/Fundamentals%20of%20Circuit%20Analysis%20and%20Experiment/" title="Fundamentals of Circuit Analysis and Experiment(持续更新中)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Fundamentals of Circuit Analysis and Experiment(持续更新中)</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/25/C++/cpp_10/" title="顺序容器(上)——跟我一起从C到C++(第十期)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_14.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">顺序容器(上)——跟我一起从C到C++(第十期)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/25/C++/cpp_10/" title="顺序容器(上)——跟我一起从C到C++(第十期)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_14.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-25</div><div class="title">顺序容器(上)——跟我一起从C到C++(第十期)</div></div></a></div><div><a href="/2023/02/11/ProgramLog/KMP%E7%AE%97%E6%B3%95_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%92%8C%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/" title="【KMP算法】算法分析和代码解析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_15.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-11</div><div class="title">【KMP算法】算法分析和代码解析</div></div></a></div><div><a href="/2023/02/09/ProgramLog/CPP_%E5%A4%8D%E6%9D%82%E8%AE%A1%E7%AE%97%E5%99%A8/" title="【C&#x2F;C++】 复杂计算器——四则运算表达式求值（中缀转后缀表达式）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-09</div><div class="title">【C&#x2F;C++】 复杂计算器——四则运算表达式求值（中缀转后缀表达式）</div></div></a></div><div><a href="/2023/02/07/C++/cpp_9/" title="IO库——跟我一起从C到C++(第九期)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-07</div><div class="title">IO库——跟我一起从C到C++(第九期)</div></div></a></div><div><a href="/2023/02/05/C++/cpp_8/" title="类(下)——跟我一起从C到C++(第八期)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-05</div><div class="title">类(下)——跟我一起从C到C++(第八期)</div></div></a></div><div><a href="/2023/02/03/ProgramLog/Linux_C_%E5%AE%9E%E7%8E%B0ls-R%E7%9A%84%E5%91%BD%E4%BB%A4/" title="【Linux C&#x2F;C++】 实现ls -R的命令"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_8.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-03</div><div class="title">【Linux C&#x2F;C++】 实现ls -R的命令</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/pearl.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">瑞奇</div><div class="author-info__description">一个心怀浪漫的少年</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://blog.csdn.net/DreamTrue520?spm=1011.2124.3001.5343"><i></i><span>🛴前往小家...</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/info/wechat" target="_blank" title="WeChat"><i class="fab fa-weixin"></i></a><a class="social-icon" href="/info/qq" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="https://github.com/mico845" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1120845871@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="toc-text">10 顺序容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-%E7%AE%A1%E7%90%86%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">10.4 管理迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-1-%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C%E5%8F%AF%E8%83%BD%E4%BD%BF%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="toc-text">10.4.1 容器操作可能使迭代器失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-2-%E6%94%B9%E5%8F%98%E5%AE%B9%E5%99%A8%E7%9A%84%E5%BE%AA%E7%8E%AF"><span class="toc-text">10.4.2 改变容器的循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5-vector%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%A2%9E%E9%95%BF%E7%9A%84"><span class="toc-text">10.5 vector对象是如何增长的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-1-%E7%AE%A1%E7%90%86%E5%AE%B9%E9%87%8F"><span class="toc-text">10.5.1 管理容量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-6-%E9%A2%9D%E5%A4%96%E7%9A%84string%E6%93%8D%E4%BD%9C"><span class="toc-text">10.6 额外的string操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6-1-%E6%9E%84%E9%80%A0string%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-text">10.6.1 构造string的其他方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6-2-substr%E6%93%8D%E4%BD%9C"><span class="toc-text">10.6.2 substr操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6-3-%E6%94%B9%E5%8F%98string%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-text">10.6.3 改变string的其他方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6-4-%E6%90%9C%E7%B4%A2%E6%93%8D%E4%BD%9C"><span class="toc-text">10.6.4 搜索操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6-5-compare%E5%87%BD%E6%95%B0"><span class="toc-text">10.6.5 compare函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6-6-%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2"><span class="toc-text">10.6.6 数值转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-7-%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text">10.7 容器适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7-1-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text">10.7.1 定义一个适配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7-2-%E6%A0%88%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text">10.7.2 栈适配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7-3-%E9%98%9F%E5%88%97%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text">10.7.3 队列适配器</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 瑞奇</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-tag-plugins@latest/lib/mindmap.min.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>